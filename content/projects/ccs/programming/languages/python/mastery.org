+++
title = "@@html:<input type=\"checkbox\" class=\"refactor\" style=\"transform: scale(1.4); vertical-align: middle; margin-right: 8px;\"/>@@Mastering Python"
tags = ["sharpen"]
+++

{{< collapse id="mastery-python" lvl="3" >}}
#+begin_export html
<aside class="custom-toc">
<nav>
<p class="sidebar__heading">Table Of Contents</p>
#+end_export

#+toc: headlines 2

#+begin_export html
</nav></aside>
#+end_export


Source: https://www.w3resource.com/python-exercises/python_100_exercises_with_solutions.php

** preamble                                                        :noexport:

#+PROPERTY: dest /Users/aayushbajaj/Documents/new-site/static/code/ccs/programming/languages/100-days-python/mastery/
#+OPTIONS: todo:nil d:nil p:nil
#+OPTIONS: d:(not "LOGBOOK")



#+begin_src emacs-lisp
(setq ndk/tangle-dir (org-entry-get nil "dest" t))

(defun ndk/org-babel-tangle-rename ()
  (let ((tangledir ndk/tangle-dir)
        (tanglefile (buffer-file-name)))
      (rename-file tanglefile tangledir t)))

(add-hook 'org-babel-post-tangle-hook #'ndk/org-babel-tangle-rename)
#+end_src

#+RESULTS:
| ndk/org-babel-tangle-rename |


** DONE Exercise 1:
:LOGBOOK:
CLOSED: [2025-03-10 Mon 13:32]
- State "DONE"       from "TODO"       [2025-03-10 Mon 13:32]
:END:

Create a list with values ranging from 0 to 9.

*** soln

list's take in iterators
#+begin_src jupyter-python :session mast-python :tangle q1.py
  #my_list = [i for i in range(10)]
  my_list = list(range(10))
  my_list
#+end_src

*** output
#+RESULTS:
| 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 |

** DONE Exercise 2:
CLOSED: [2025-03-10 Mon 13:32]
:LOGBOOK:
- State "DONE"       from              [2025-03-10 Mon 13:32]
:END:

Convert a list of integers to a list of strings.

*** soln

=map(function, iterable, *iterables)=
map returns an iterator. it applies fn to an iterator with iterable args.
#+begin_src jupyter-python :session mast-python :tangle q2.py
  my_list_as_strs = list(map(str, my_list))
  my_list_as_strs
#+end_src

*** output
#+RESULTS:
| 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 |

** DONE Exercise 3:
CLOSED: [2025-03-10 Mon 13:32]
:LOGBOOK:
- State "DONE"       from              [2025-03-10 Mon 13:32]
:END:

Multiply all elements in a list by 2.

*** soln

a very functional programming approach; manipulating data with subsequent functional transformations.

also, unusually I could not find any documentation on lambda expressions in the main [[https://docs.python.org/3/library/index.html][Python Standard Library]]. I had to click into the tutorial and take a look at [[https://docs.python.org/3/tutorial/controlflow.html#lambda-expressions]["more control flow tools"]].
#+begin_src jupyter-python :session mast-python :tangle q3.py
  another_list = list(range(5))
  times_two_list = list(map(lambda x: 2*x, another_list))
  times_two_list
#+end_src

*** output
#+RESULTS:
| 0 | 2 | 4 | 6 | 8 |


** DONE Exercise 4:
CLOSED: [2025-03-10 Mon 13:32]
:LOGBOOK:
- State "DONE"       from              [2025-03-10 Mon 13:32]
:END:

Extract all odd numbers from a list of integers.

*** soln

maps continue to be useful, however perhaps a filter will be a better idea here.

#+begin_src jupyter-python :session mast-python :tangle q4.py
  another_list = list(range(20))
  odd_lists = list(filter(lambda x: x%2==1, another_list))
  odd_lists
#+end_src

the modulo 2 case would equal 1 whenever an odd number was given. we're spitting out the cases of which that was true:
*** output
#+RESULTS:
| 1 | 3 | 5 | 7 | 9 | 11 | 13 | 15 | 17 | 19 |

** DONE Exercise 5:
CLOSED: [2025-03-10 Mon 13:32]
:LOGBOOK:
- State "DONE"       from              [2025-03-10 Mon 13:32]
:END:

Replace all odd numbers in a list with -1.

*** soln

we go back to a map for this one.

note that the ternary operator syntax is different to C/Java.
#+begin_src jupyter-python :session mast-python :tangle q5.py
  another_list = list(range(20))
  odd_lists_minus_one = list(map(lambda x:-1 if x%2==1 else x, another_list))
  odd_lists_minus_one
#+end_src
*** output
#+RESULTS:
| 0 | -1 | 2 | -1 | 4 | -1 | 6 | -1 | 8 | -1 | 10 | -1 | 12 | -1 | 14 | -1 | 16 | -1 | 18 | -1 |

** DONE Exercise 6:
CLOSED: [2025-03-11 Tue 12:55]
:LOGBOOK:
- State "DONE"       from              [2025-03-11 Tue 12:55]
:END:

Convert a list of integers to a list of booleans where all non-zero values become True.

*** soln

note that in Python, true is actually =True= and false, =False=.

#+begin_src jupyter-python :session mast-python :tangle q6.py
  list_ints = list(range(15))
  bool_list = list(map(lambda x: True if x != 0 else False, list_ints))
  bool_list
#+end_src

*** output
#+RESULTS:
| False | True | True | True | True | True | True | True | True | True | True | True | True | True | True |

** DONE Exercise 7:
CLOSED: [2025-03-11 Tue 12:55]
:LOGBOOK:
- State "DONE"       from              [2025-03-11 Tue 12:55]
:END:

Replace all even numbers in a list with their negative.

#+begin_src jupyter-python :session mast-python :tangle q7.py
  list_ints = list(range(15))
  neg_list = list(map(lambda x: -x if x % 2 == 0 else x, list_ints))
  neg_list
#+end_src

#+RESULTS:
| 0 | 1 | -2 | 3 | -4 | 5 | -6 | 7 | -8 | 9 | -10 | 11 | -12 | 13 | -14 |

** DONE Exercise 8:
CLOSED: [2025-03-11 Tue 12:55]
:LOGBOOK:
- State "DONE"       from              [2025-03-11 Tue 12:55]
:END:

Create a 3x3 list of lists with random values and normalize it.

*** soln

crazy: notice that the =randint= bounds are <= and >=!
#+begin_src jupyter-python :session mast-python :tangle q8.py
  import random
  random.seed(4)
  def create_n_by_n_list(n):
	return [[random.randint(0,n) for i in range(n)] for i in list(range(0,n))]
  def normalise_list(l, n):
	import numpy
	return numpy.array(l) / n
  my_list = create_n_by_n_list(6)
  norm_list = normalise_list(my_list, 6)
  print(norm_list)
#+end_src

#+RESULTS:
: [[0.16666667 0.33333333 0.         0.83333333 0.5        0.5       ]
:  [0.16666667 0.         0.         0.         0.5        0.66666667]
:  [0.33333333 1.         1.         0.         0.16666667 0.66666667]
:  [0.66666667 0.33333333 0.33333333 1.         0.16666667 1.        ]
:  [0.         0.33333333 0.16666667 0.         1.         0.83333333]
:  [1.         0.33333333 1.         0.33333333 0.16666667 0.16666667]]

*** output

I generalised the problem to nxn.

also I used numpy to skip a list comprehension.
#+RESULTS:
: [[0.16666667 0.33333333 0.         0.83333333 0.5        0.5       ]
:  [0.16666667 0.         0.         0.         0.5        0.66666667]
:  [0.33333333 1.         1.         0.         0.16666667 0.66666667]
:  [0.66666667 0.33333333 0.33333333 1.         0.16666667 1.        ]
:  [0.         0.33333333 0.16666667 0.         1.         0.83333333]
:  [1.         0.33333333 1.         0.33333333 0.16666667 0.16666667]]

** DONE Exercise 9:
CLOSED: [2025-03-11 Tue 12:55]
:LOGBOOK:
- State "DONE"       from              [2025-03-11 Tue 12:55]
:END:

Calculate the sum of the diagonal elements of a 3x3 matrix (list of lists).

*** soln

#+begin_src jupyter-python :session mast-python :tangle q9.py
  import numpy
  print(sum(numpy.diag(norm_list)))
#+end_src

#+RESULTS:
: 3.3333333333333335

** DONE Exercise 10:
CLOSED: [2025-03-11 Tue 12:55]
:LOGBOOK:
- State "DONE"       from              [2025-03-11 Tue 12:55]
:END:

Find the indices of non-zero elements in a list.

*** soln

this notation is illegal: =lambda i, v:=
#+begin_src jupyter-python :session mast-python :tangle q10.py
  new_list = list(range(-5, 4))
  tuple_list = filter(lambda t: t[1] != 0, enumerate(new_list)) # filter correct tuples
  out_list = [e[0] for e in tuple_list] # construct list of indices
  out_list
#+end_src

*** output
fk that was hard.
#+RESULTS:
| 0 | 1 | 2 | 3 | 4 | 6 | 7 | 8 |

** DONE Exercise 11:
CLOSED: [2025-03-12 Wed 11:15]
:LOGBOOK:
- State "DONE"       from              [2025-03-12 Wed 11:15]
:END:

Reverse a list.

*** soln
one thing to be careful of with the =list.reverse()= method is that the reversal happens "in-place", i.e. on the object that the method was called on.
#+begin_src jupyter-python :session mast-python :tangle q11.py
  out_list.reverse() # no return value for this
  print(out_list)
  print(new_list) # defined in the last q
  print(reversed(new_list)) # returns an iterator object
  print(list(reversed(new_list)))
#+end_src


#+RESULTS:
: [8, 7, 6, 4, 3, 2, 1, 0]
: [-5, -4, -3, -2, -1, 0, 1, 2, 3]
: <list_reverseiterator object at 0x107bdf8b0>
: [3, 2, 1, 0, -1, -2, -3, -4, -5]

further, it must noted that all the above are "shallow-copies", whilst they are fast, if the objects which constitute the list are mutable, then you could run into problems with the reversed list misbehaving later:

#+begin_src jupyter-python :session mast-python
  x = 6
  a = 7
  b = 8
  var_list = [x, a, b]
  print(f"var_list: {var_list}")
  stable_list = var_list[::-1]
  question_list = list(reversed(var_list))
  x = 1
  a = 2
  b = 3
  unstable_list = list(reversed(var_list))
  print(question_list)
  print(unstable_list)
  print(stable_list)
#+end_src

now, notice that you STILL cannot see a difference! this is because your =x,a,b= variables are immutable; they are integers.
#+RESULTS:
: var_list: [6, 7, 8]
: [8, 7, 6]
: [8, 7, 6]
: [8, 7, 6]

try this code
#+begin_src jupyter-python :session mast-python
  x = [6]
  a = [7]
  b = [8]
  var_list = [x, a, b]
  print(f"var_list: {var_list}")
  stable_list = var_list[::-1]
  question_list = list(reversed(var_list))
  x.append(1)
  a.append(2)
  b.append(3)
  unstable_list = list(reversed(var_list))
  print(f"question_list: {question_list}")
  print(f"unstable_list: {unstable_list}")
  print(f"stable_list: {stable_list}")
#+end_src

#+RESULTS:
: var_list: [[6], [7], [8]]
: question_list: [[8, 3], [7, 2], [6, 1]]
: unstable_list: [[8, 3], [7, 2], [6, 1]]
: stable_list: [[8, 3], [7, 2], [6, 1]]

ultimately, if you want a non-shallow copy you must use deepcopy
#+begin_src jupyter-python :session mast-python
  import copy
  stable_list = copy.deepcopy(var_list)
  print(f"stable_list: {stable_list}")
  # and now, even if you mutate the lists, stable_list does not change but unstable_list will:
  x.pop()
  print(f"unstable_list: {unstable_list}")
  print(f"still stable: {stable_list}")
#+end_src

#+RESULTS:
: stable_list: [[6, 1], [7, 2], [8, 3]]
: unstable_list: [[8, 3], [7, 2], [6]]
: still stable: [[6, 1], [7, 2], [8, 3]]

** DONE Exercise 12:
CLOSED: [2025-03-12 Wed 11:15]
:LOGBOOK:
- State "DONE"       from "DONE"       [2025-03-12 Wed 11:15]
- State "DONE"       from              [2025-03-12 Wed 11:15]
:END:

Create a 3x3 identity matrix as a list of lists.

#+begin_src jupyter-python :session mast-python :tangle q12.py
  import numpy as np
  print(np.eye(3))
#+end_src

#+RESULTS:
: [[1. 0. 0.]
:  [0. 1. 0.]
:  [0. 0. 1.]]

** DONE Exercise 13:
CLOSED: [2025-03-12 Wed 11:15]
:LOGBOOK:
- State "DONE"       from              [2025-03-12 Wed 11:15]
:END:

Reshape a 1D list to a 2D list with 2 rows.

*** soln1
#+begin_src jupyter-python :session mast-python :tangle q13.py
  l = np.array(range(12))
  print(l.reshape(2, -1))
#+end_src

*** output
#+RESULTS:
: [[ 0  1  2  3  4  5]
:  [ 6  7  8  9 10 11]]

*** soln2, no numpy
#+begin_src jupyter-python :session mast-python :tangle q13b.py
  l = list(range(12))
  x = [l[x:x+int(len(l)/2)] for x in range(0, len(l), int(len(l)/2))]
  print(x)
#+end_src

*** output
terrific, well done!
#+RESULTS:
: [[0, 1, 2, 3, 4, 5], [6, 7, 8, 9, 10, 11]]

** DONE Exercise 14:
CLOSED: [2025-03-12 Wed 11:15]
:LOGBOOK:
- State "DONE"       from              [2025-03-12 Wed 11:15]
:END:

Stack two lists vertically.

#+begin_src jupyter-python :session mast-python :tangle q14.py
  l1 = list(range(4))[::-1]
  l2 = list(range(4))
  l = [l1, l2]
  print(l)
#+end_src

#+RESULTS:
: [[3, 2, 1, 0], [0, 1, 2, 3]]

** DONE Exercise 15:
CLOSED: [2025-03-12 Wed 11:15]
:LOGBOOK:
- State "DONE"       from              [2025-03-12 Wed 11:15]
:END:

Get the common items between two lists.

shit, I accidentally got all the /unique/ items by using sets
#+begin_src jupyter-python :session mast-python :tangle q15.py
  l1 = list(range(4))[::-1]
  l2 = list(range(7))
  l1.extend(l2)
  s = list(set(l1))
  print(s)
#+end_src

#+RESULTS:
: [0, 1, 2, 3, 4, 5, 6]

that's okay, it's not much different to find the duplicates; we can use the =intersection= method of =sets=
#+begin_src jupyter-python :session mast-python
  l1 = list(range(4))[::-1]
  l2 = list(range(7))
  dupes = list(set(l1).intersection(set(l2)))
  # also, note that the intersection method can accept any iterable! thus this works too:
  dupes = list(set(l1).intersection(l2))
  print(dupes)
#+end_src

*** output
#+RESULTS:
: [0, 1, 2, 3]

** DONE Exercise 16:
CLOSED: [2025-03-13 Thu 15:41]
:LOGBOOK:
- State "DONE"       from              [2025-03-13 Thu 15:41]
:END:

Create a 5x5 list of lists with row values ranging from 0 to 4.

*** soln1

#+begin_src jupyter-python :session mast-python :tangle q16.py
  import random
  random.seed(4)
  n = 5
  l = [ [random.randint(0,n-1) for i in range(n)] for i in range(n)]
  print(l)
#+end_src

#+RESULTS:
: [[1, 2, 0, 3, 3], [1, 0, 0, 0, 3], [4, 2, 0, 1, 4], [4, 2, 2, 1, 0], [2, 1, 0, 2, 2]]

*** soln2
i believe we can accomplish the same thing more quickly with numpy:

#+begin_src jupyter-python :session mast-python
  import numpy
  m = numpy.random.randint(5, size=(5,5))
  print(m)
#+end_src

#+RESULTS:
: [[2 3 1 3 3]
:  [0 4 4 3 3]
:  [3 2 0 2 2]
:  [4 3 4 1 2]
:  [1 4 0 0 4]]

*** timing

#+begin_src jupyter-python :session mast-python
import timeit

# Setup code for the list-comprehension approach
setup1 = """
import random
random.seed(4)
n = 5
"""

# The statement we want to time repeatedly
stmt1 = """
l = [[random.randint(0, n - 1) for i in range(n)] for j in range(n)]
"""

# Setup code for the NumPy approach
setup2 = """
import numpy
"""

# The statement we want to time repeatedly
stmt2 = """
m = numpy.random.randint(5, size=(5, 5))
"""

# Number of iterations to run timeit
iterations = 1_000_000

time1 = timeit.timeit(stmt=stmt1, setup=setup1, number=iterations)
time2 = timeit.timeit(stmt=stmt2, setup=setup2, number=iterations)

print(f"List comprehension approach: {time1:.6f} seconds")
print(f"NumPy approach:              {time2:.6f} seconds")
#+end_src

#+RESULTS:
: List comprehension approach: 7.771532 seconds
: NumPy approach:              3.685444 seconds


** DONE Exercise 17:
CLOSED: [2025-03-13 Thu 15:41]
:LOGBOOK:
- State "DONE"       from              [2025-03-13 Thu 15:41]
:END:

Find the index of the maximum value in a list.

*** soln
#+begin_src jupyter-python :session mast-python
max(max(l))
#+end_src

#+RESULTS:
: 4

and for a single dimensional array (the above was 2d)
#+begin_src jupyter-python :session mast-python
max(range(15))
#+end_src

#+RESULTS:
: 14

however, the number of =max= calls is clearly dependent on the dimensionality. as such we can use =numpy=:
#+begin_src jupyter-python :session mast-python :tangle q17.py
numpy.amax(l)
#+end_src

#+RESULTS:
: 4

** DONE Exercise 18:
CLOSED: [2025-03-13 Thu 15:41]
:LOGBOOK:
- State "DONE"       from              [2025-03-13 Thu 15:41]
:END:

Normalize the values in a list between 0 and 1.

we can do it nakedly with the =math= library and implement softmax, which is defined in [[https://abaj.ai/projects/mathematics/calculus/mvars#softmax][multi-variate calculus]].
#+begin_src jupyter-python :session mast-python :tangle q18.py
  import math
  my_list = list(range(7))
  new_list = list(map(lambda x: math.exp(x) / sum(math.exp(y) for y in my_list), my_list))
  print(new_list)
  print(sum(new_list)) # checking it all sums to 1
#+end_src

#+RESULTS:
: [0.0015683003158864725, 0.004263082250240778, 0.011588259014055805, 0.03150015390138463, 0.08562629594379713, 0.23275640430228017, 0.6326975042723549]
: 0.9999999999999999

#+begin_src jupyter-python :session mast-python :tangle q18b.py
  import numpy as np
  def softmax(x):
      return np.exp(x) / sum(np.exp(x))

  print(sum(softmax(my_list)))
  print(softmax(my_list))
#+end_src

#+RESULTS:
: 0.9999999999999999
: [0.0015683  0.00426308 0.01158826 0.03150015 0.0856263  0.2327564
:  0.6326975 ]

** DONE Exercise 19:
CLOSED: [2025-03-13 Thu 15:41]
:LOGBOOK:
- State "DONE"       from              [2025-03-13 Thu 15:41]
:END:

Calculate the dot product of two lists.

#+begin_src jupyter-python :session mast-python :tangle q19.py
  random.seed(4)
  list_a = random.choices(range(10),k=10) # without numpy
  list_b = random.choices(range(10),k=10)
  print(list_a)
  print(list_b)
  dot_p = sum(list(map(math.prod, zip(list_a,list_b))))
  print(dot_p)
#+end_src

#+RESULTS:
: [2, 1, 3, 1, 0, 4, 9, 8, 7, 2]
: [5, 2, 1, 1, 2, 9, 8, 8, 8, 1]
: 246

** DONE Exercise 20:
CLOSED: [2025-03-13 Thu 15:41]
:LOGBOOK:
- State "DONE"       from              [2025-03-13 Thu 15:41]
:END:

Count the number of elements in a list within a specific range.

#+begin_src jupyter-python :session mast-python :tangle q20.py
  def count_elements_within_range(a, b, x):
      return sum(a <= y <= b for y in x)
  count_elements_within_range(5, 12, list(range(14))[5::3])
#+end_src

#+RESULTS:
: 3

** DONE Exercise 21:
CLOSED: [2025-03-13 Thu 15:46]
:LOGBOOK:
- State "DONE"       from              [2025-03-13 Thu 15:46]
:END:

Find the mean of each row in a 2D list.

#+begin_src jupyter-python :session mast-python :tangle q21.py
  def average(l):
      return sum(l)/len(l)

  """ takes in list of lists
      returns list of averages, one for each row
  """
  def mean_list_of_rows(ml):
    return [average(x) for x in ml]

  my_list = [[1,2,3],[4,5],[3,3]]
  mean_list_of_rows(my_list)
#+end_src

#+RESULTS:
| 2.0 | 4.5 | 3.0 |

** DONE Exercise 22:
CLOSED: [2025-03-18 Tue 09:51]
:LOGBOOK:
- State "DONE"       from              [2025-03-18 Tue 09:51]
:END:

Create a random 4x4 list of lists and extract the diagonal elements.

#+begin_src jupyter-python :session mast-python :tangle q22.py
  import numpy as np
  list_of_lists = np.random.randint(10, size=(4,4))
  print(list_of_lists)
  np.diag(list_of_lists)
#+end_src

#+RESULTS:
:RESULTS:
: [[4 6 4 0]
:  [9 2 2 1]
:  [9 0 6 7]
:  [7 3 1 4]]
: array([4, 2, 6, 4])
:END:

** DONE Exercise 23:
CLOSED: [2025-03-18 Tue 09:53]
:LOGBOOK:
- State "DONE"       from              [2025-03-18 Tue 09:53]
:END:

Count the number of occurrences of a specific value in a list.

#+begin_src jupyter-python :session mast-python :tangle q23.py
range_list = list(range(6))
range_list.count(4)
#+end_src

#+RESULTS:
: 1

** DONE Exercise 24:
CLOSED: [2025-03-18 Tue 09:53]
:LOGBOOK:
- State "DONE"       from              [2025-03-18 Tue 09:53]
:END:

Replace all values in a list with the mean of the list.

#+begin_src jupyter-python :session mast-python :tangle q24.py
  range_list = list(range(6))
  range_list = [average(range_list) for x in range_list]
  print(range_list)
#+end_src

#+RESULTS:
: [2.5, 2.5, 2.5, 2.5, 2.5, 2.5]

** DONE Exercise 25:
CLOSED: [2025-03-18 Tue 09:53]
:LOGBOOK:
- State "DONE"       from              [2025-03-18 Tue 09:53]
:END:

Find the indices of the maximum and minimum values in a list.

#+begin_src jupyter-python :session mast-python :tangle q25.py
  range_list = list(range(6))
  print(range_list.index(min(range_list)))
  print(range_list.index(max(range_list)))
#+end_src

#+RESULTS:
: 0
: 5

you of course also have the numpy method, however that requires the overhead of converting to a numpy array first:
#+begin_src jupyter-python :session mast-python
  range_list = list(range(6))
  print(np.argmin(range_list))
  print(np.argmax(range_list))
#+end_src

#+RESULTS:
: 0
: 5

** DONE Exercise 26:
CLOSED: [2025-03-18 Tue 09:53]
:LOGBOOK:
- State "DONE"       from              [2025-03-18 Tue 09:53]
:END:

Create a 2D list with 1 on the border and 0 inside.

#+begin_src jupyter-python :session mast-python :tangle q26.py
  # note this program only works for odd n
  n = 3
  mat = np.ones((n,n))
  mat[n//2][n//2] = 0
  print(mat)
#+end_src

#+RESULTS:
: [[1. 1. 1.]
:  [1. 0. 1.]
:  [1. 1. 1.]]

** DONE Exercise 27:
CLOSED: [2025-03-18 Tue 09:53]
:LOGBOOK:
- State "DONE"       from              [2025-03-18 Tue 09:53]
:END:

Find the unique values and their counts in a list.

#+begin_src jupyter-python :session mast-python :tangle q27.py
  l1 = list(range(6))
  l2 = list(range(2,7))
  l1.extend(l2)
  uniq = list(set(l1))
  counts = {x: l1.count(x) for x in l1}
  print(counts)
  print(uniq)
#+end_src

#+RESULTS:
: {0: 1, 1: 1, 2: 2, 3: 2, 4: 2, 5: 2, 6: 1}
: [0, 1, 2, 3, 4, 5, 6]

** DONE Exercise 28:
CLOSED: [2025-03-18 Tue 09:53]
:LOGBOOK:
- State "DONE"       from              [2025-03-18 Tue 09:53]
:END:

Create a 3x3 list of lists with values ranging from 0 to 8.

#+begin_src jupyter-python :session mast-python :tangle q28.py
  nums = list(range(9))
  ll_nums = [nums[x:x+3] for x in range(0,9,3)]
  print(ll_nums)
#+end_src

#+RESULTS:
: [[0, 1, 2], [3, 4, 5], [6, 7, 8]]

** DONE Exercise 29:
CLOSED: [2025-03-18 Tue 09:54]
:LOGBOOK:
- State "DONE"       from              [2025-03-18 Tue 09:54]
:END:

Calculate the exponential of all elements in a list.

#+begin_src jupyter-python :session mast-python :tangle q29.py
  import math
  nums = list(range(9))
  nums = [math.exp(x) for x in nums]
  print(nums)
#+end_src

#+RESULTS:
: [1.0, 2.718281828459045, 7.38905609893065, 20.085536923187668, 54.598150033144236, 148.4131591025766, 403.4287934927351, 1096.6331584284585, 2980.9579870417283]

** DONE Exercise 30:
CLOSED: [2025-03-18 Tue 09:54]
:LOGBOOK:
- State "DONE"       from              [2025-03-18 Tue 09:54]
:END:

Swap two rows in a 2D list.

#+begin_src jupyter-python :session mast-python :tangle q30.py
  import random
  matrix = create_n_by_n_list(4)
  print(matrix)
  matrix[0], matrix[1] = matrix[1], matrix[0]
  print(matrix)
#+end_src

#+RESULTS:
: [[2, 2, 2, 0], [4, 2, 3, 4], [1, 1, 1, 3], [2, 0, 4, 2]]
: [[4, 2, 3, 4], [2, 2, 2, 0], [1, 1, 1, 3], [2, 0, 4, 2]]

** DONE Exercise 31:
CLOSED: [2025-03-18 Tue 10:05]
:LOGBOOK:
- State "DONE"       from              [2025-03-18 Tue 10:05]
:END:

Create a random 3x3 list of lists and replace all values greater than 0.5 with 1 and all others with 0.

*** soln
#+begin_src jupyter-python :session mast-python :tangle q31.py
  import random
  random.seed(3)
  print([[1 if random.random() > 0.5 else 0 for _ in range(3)] for _ in range(3)]) 
#+end_src

*** output
#+RESULTS:
: [[0, 1, 0], [1, 1, 0], [0, 1, 0]]

** DONE Exercise 32:
CLOSED: [2025-03-18 Tue 10:17]
:LOGBOOK:
- State "DONE"       from              [2025-03-18 Tue 10:17]
:END:

Find the indices of the top N maximum values in a list.

*** soln
#+begin_src jupyter-python :session mast-python :tangle q32.py
  top_n_idx = lambda x,n: list(list(zip(*sorted(enumerate(x), key=lambda x:x[1], reverse=True)))[0][:n:])
  print(top_n_idx([1, 2, 6, 4], 3))
#+end_src

*** output
#+RESULTS:
: [2, 3, 1]


** DONE Exercise 33:
CLOSED: [2025-03-19 Wed 21:15]
:LOGBOOK:
- State "DONE"       from              [2025-03-19 Wed 21:15]
:END:

Calculate the mean of each column in a 2D list.

*** soln (oops sums over rows!)
#+begin_src jupyter-python :session mast-python :tangle q33z.py
  mean_cols = lambda l: [sum(l[i]) / len(l) for i in range(len(l))]
  n = 5
  d2_list = [[random.randint(0,10) for _ in range(n)] for _ in range(n)]
  print(mean_cols(d2_list))
#+end_src

#+RESULTS:
: [5.4, 6.0, 7.4, 6.0, 5.2]

*** soln (over cols)
#+begin_src jupyter-python :session mast-python :tangle q33a.py
  mean_cols = lambda l: [sum(row[i] for row in l) / len(l) for i in range(len(l))]
  n = 5
  d2_list = [[random.randint(0,10) for _ in range(n)] for _ in range(n)]
  print(mean_cols(d2_list))
#+end_src

#+RESULTS:
: [2.6, 4.6, 5.6, 3.2, 3.6]


** DONE Exercise 34:
CLOSED: [2025-03-19 Wed 21:15]
:LOGBOOK:
- State "DONE"       from              [2025-03-19 Wed 21:15]
:END:

Normalize the values in each column of a 2D list.

*** soln
#+begin_src jupyter-python :session mast-python :tangle q34.py
  random.seed(4)
  mean_cols = lambda l: [
	[l[r][c] / sum(l[i][c] for i in range(len(l[r])))
	 for c in range(len(l[r]))]
	for r in range(len(l))
    ]
  n = 5
  d2_list = [[random.randint(0,10) for _ in range(n)] for _ in range(n)]
  print("original matrix:", d2_list)
  print(mean_cols(d2_list))
#+end_src

*** output
#+RESULTS:
: original matrix: [[3, 4, 1, 6, 7], [2, 1, 1, 0, 6], [8, 4, 0, 3, 8], [8, 5, 4, 2, 1], [4, 3, 0, 10, 4]]
: [[0.12, 0.23529411764705882, 0.16666666666666666, 0.2857142857142857, 0.2692307692307692], [0.08, 0.058823529411764705, 0.16666666666666666, 0.0, 0.23076923076923078], [0.32, 0.23529411764705882, 0.0, 0.14285714285714285, 0.3076923076923077], [0.32, 0.29411764705882354, 0.6666666666666666, 0.09523809523809523, 0.038461538461538464], [0.16, 0.17647058823529413, 0.0, 0.47619047619047616, 0.15384615384615385]]

*** lessons
1. you need be careful along the axis which you are computing index calculations on
2. if you are going to use huge lambda functions, at least indent them and split them across multiple lines.

** DONE Exercise 35:
CLOSED: [2025-03-19 Wed 21:15]
:LOGBOOK:
- State "DONE"       from              [2025-03-19 Wed 21:15]
:END:

Concatenate two lists.

*** soln
#+begin_src jupyter-python :session mast-python :tangle q35.py
  l1 = list(range(5))
  l2 = ['a', 'b', 'string']
  l1.extend(l2)
  print(l1)
#+end_src

*** output
#+RESULTS:
: [0, 1, 2, 3, 4, 'a', 'b', 'string']

** DONE Exercise 36:
CLOSED: [2025-03-19 Wed 21:37]
:LOGBOOK:
- State "DONE"       from              [2025-03-19 Wed 21:37]
:END:

Create a 2D list with random values and sort each row.

*** soln
#+begin_src jupyter-python :session mast-python :tangle q36.py
  import random
  n = 3
  sort_rows = lambda l: [sorted(row) for row in l]
  print(sort_rows([[random.randint(0,n) for _ in range(n)] for _ in range(n)]))
#+end_src

*** output
#+RESULTS:
: [[0, 3, 3], [2, 2, 3], [0, 3, 3]]

** DONE Exercise 37:
CLOSED: [2025-03-19 Wed 21:37]
:LOGBOOK:
- State "DONE"       from              [2025-03-19 Wed 21:37]
:END:

Check if all elements in a list are non-zero.

*** soln(bad)
#+begin_src jupyter-python :session mast-python :tangle q37bad.py
  my_list = [random.randint(0,n) for _ in range(n)]
  check_nonzero = lambda l: True if len(list(filter(lambda x: x == 0, l))) == 0 else False
  print(my_list)
  print(check_nonzero(my_list))

#+end_src

*** output
#+RESULTS:
: [3, 3, 3]
: True
#+RESULTS:
: [3, 0, 3]
: False

*** soln(good)
#+begin_src jupyter-python :session mast-python :tangle q37pythonic.py
  my_list = [random.randint(0,n) for _ in range(n)]
  check_nonzero = lambda l: all(l)
  print(my_list)
  print(check_nonzero(my_list))
#+end_src

*** output
#+RESULTS:
: [0, 3, 2]
: False

#+RESULTS:
: [3, 3, 3]
: True

** DONE Exercise 38:
CLOSED: [2025-03-25 Tue 00:53]
:LOGBOOK:
- State "DONE"       from              [2025-03-25 Tue 00:53]
:END:

Find the indices of the maximum value in each row of a 2D list.

*** soln
#+begin_src jupyter-python :session mast-python :tangle q38.py
  my_list = [[random.randint(0,n+2) for _ in range(n)] for _ in range(n)]
  max_idx_rows_as_list = lambda l: list(map(lambda x: x.index(max(x)), l))
  print(my_list)
  print(max_idx_rows_as_list(my_list))

#+end_src

*** output
#+RESULTS:
: [[2, 0, 5], [1, 2, 3], [0, 5, 0]]
: [2, 2, 1]

** DONE Exercise 39:
CLOSED: [2025-03-25 Tue 00:53]
:LOGBOOK:
- State "DONE"       from              [2025-03-25 Tue 00:53]
:END:

Create a 2D list and replace all nan values with the mean of the list.

*** soln
#+begin_src jupyter-python :session mast-python :tangle q39.py
  my_list = [[random.randint(0,n+2) for _ in range(n)] for _ in range(n)]
  max_idx_rows_as_list = lambda l: list(map(lambda x: x.index(max(x)), l))
  print(my_list)
  print(max_idx_rows_as_list(my_list))

#+end_src

*** output

** DONE Exercise 40:
CLOSED: [2025-03-25 Tue 00:53]
:LOGBOOK:
- State "DONE"       from              [2025-03-25 Tue 00:53]
:END:

Calculate the mean of each row in a 2D list ignoring nan values.

*** soln
#+begin_src jupyter-python :session mast-python :tangle q40.py
  import math
  matrix = [[1, float('nan'), 3], [4, 5, float('nan')], [7, 8, 9]]
  #row_means = [sum(x for x in row if not math.isnan(x)) / sum(1 for x in row if not math.isnan(x)) for row in matrix]
  row_means = list(map(lambda x: sum(i for i in x if not math.isnan(i)) / sum(1 for i in x if not math.isnan(i)) , matrix))
  print(row_means)
#+end_src

*** soln
#+RESULTS:
: [2.0, 4.5, 8.0]

*** lessons
to summon a nan, you may use =float('nan')=. or you may also use

#+begin_src python
n1 = float("nan")
n2 = float("Nan")
n3 = float("NaN")
n4 = float("NAN")
print n1, n2, n3, n4
from decimal import *

n1 = Decimal("nan")
n2 = Decimal("Nan")
n3 = Decimal("NaN")
n4 = Decimal("NAN")
print n1, n2, n3, n4
import math

n1 = math.nan
print(n1)
print(math.isnan(n1))
import numpy as np

n1 = np.nan

# Check if a value is NaN
print(np.isnan(n1))
#+end_src

furthermore, to sum across elements in an unknown dimensional array, with each of the entries contributing weights, we can use =sum(i for i in x if not math.isnan(i))=.

then for when only the existence of the digit matters, you can use =sum(1 for i in x if not math.nan(i))= as above.

** DONE Exercise 41:
CLOSED: [2025-03-26 Wed 20:50]
:LOGBOOK:
- State "DONE"       from              [2025-03-26 Wed 20:50]
:END:

Compute the sum of diagonal elements in a 2D list.

*** soln
#+BEGIN_SRC jupyter-python :session mast-py :tangle q41.py
  import random
  random.seed(3)
  n = 10
  my_list = [ [random.randint(0,n) for _ in range(n) ] for _ in range(n)]
  diag_2d = lambda l: sum(l[i][i] for i in range(n))
  print(my_list)
  print(diag_2d(my_list))
#+END_SRC

#+RESULTS:
: [[3, 9, 8, 2, 5, 9, 7, 10, 9, 1], [9, 0, 7, 4, 8, 3, 3, 7, 8, 8], [7, 6, 10, 2, 3, 10, 2, 8, 6, 0], [10, 1, 2, 9, 0, 4, 0, 4, 7, 9], [6, 6, 6, 9, 7, 2, 5, 1, 0, 2], [7, 3, 4, 10, 6, 10, 4, 6, 8, 6], [9, 5, 8, 9, 6, 9, 3, 5, 10, 0], [4, 9, 10, 2, 5, 8, 9, 9, 1, 10], [3, 10, 9, 4, 4, 1, 1, 7, 10, 7], [1, 5, 1, 6, 2, 0, 4, 6, 6, 1]]
: 62

** DONE Exercise 42:
CLOSED: [2025-03-26 Wed 20:49]
:LOGBOOK:
- State "DONE"       from              [2025-03-26 Wed 20:49]
:END:

Convert radians to degrees for each element in a list.

*** soln
#+BEGIN_SRC jupyter-python :session mast-py :tangle q42.py
  import math
  convert_list = [1, 2, 0.5, 0.25]
  rad_2_deg = lambda x: [y*180/math.pi for y in x]
  #rad_2_deg = lambda x: list(map(lambda y: y*180/math.pi, x))
  print(rad_2_deg(convert_list))
#+END_SRC

#+RESULTS:
: [57.29577951308232, 114.59155902616465, 28.64788975654116, 14.32394487827058]

** DONE Exercise 43:
CLOSED: [2025-03-26 Wed 20:49]
:LOGBOOK:
- State "DONE"       from              [2025-03-26 Wed 20:49]
:END:

Calculate the pairwise Euclidean distance between two lists.

*** soln
#+BEGIN_SRC jupyter-python :session mast-py :tangle q43.py
  import math
  first_list = [1, 2, 0.5, 0.25]
  second_list = list(range(4))
  pairwise_euc = lambda x, y: [abs(i[0] - i[1]) for i in zip(x,y)]
  print(pairwise_euc(first_list, second_list))
#+END_SRC

#+RESULTS:
: [1, 1, 1.5, 2.75]

** DONE Exercise 44:
CLOSED: [2025-03-26 Wed 20:49]
:LOGBOOK:
- State "DONE"       from              [2025-03-26 Wed 20:49]
:END:

Create a list and set the values between the 25th and 75th percentile to 0.

*** soln
#+BEGIN_SRC jupyter-python :session mast-py :tangle q44.py
    def percentile(data, percentile):
      data = sorted(data)
      k = (len(data) - 1) * (percentile / 100)
      return data[int(k)]

    lst = [10, 20, 30, 40, 50]
    q1 = percentile(lst, 25)
    q3 = percentile(lst, 75)
    lst = [0 if q1 <= x <= q3 else x for x in lst]
    print(lst)

    lst = [10, 20, 30, 40, 50]
    percentile_25th = sorted(lst)[int(len(lst) * 0.25)] # indexing into the first quarter
    percentile_75th = sorted(lst)[int(len(lst) * 0.75)]
    lst = [0 if percentile_25th <= x <= percentile_75th else x for x in lst]
    print(lst)

#+END_SRC

#+RESULTS:
: [10, 0, 0, 0, 50]
: [10, 0, 0, 0, 50]

** DONE Exercise 45:
CLOSED: [2025-03-26 Wed 20:49]
:LOGBOOK:
- State "DONE"       from              [2025-03-26 Wed 20:49]
:END:

Calculate the element-wise square of the difference between two lists.

*** soln
#+BEGIN_SRC jupyter-python :session mast-py :tangle q45.py
  import math
  first_list = [1, 2, 0.5, 0.25]
  second_list = list(range(4))
  pairwise_squared = lambda x, y: [(i[0] - i[1])**2 for i in zip(x,y)]
  print(pairwise_euc(first_list, second_list))
#+END_SRC

#+RESULTS:
: [1, 1, 2.25, 7.5625]

** DONE Exercise 46:
CLOSED: [2025-03-26 Wed 20:52]
:LOGBOOK:
- State "DONE"       from              [2025-03-26 Wed 20:52]
:END:

Replace all even numbers in a list with the next odd number.

*** soln
#+BEGIN_SRC jupyter-python :session mast-py :tangle q46.py
  my_list = list(range(10))
  replace_evens = lambda l: list(map(lambda y: y+1 if y%2==0 else y, l))
  print(replace_evens(my_list))
#+END_SRC

#+RESULTS:
: [1, 1, 3, 3, 5, 5, 7, 7, 9, 9]

** DONE Exercise 47:
CLOSED: [2025-03-26 Wed 22:06]
:LOGBOOK:
- State "DONE"       from              [2025-03-26 Wed 22:06]
:END:

Create a 2D list and normalize each column by its range.

*** soln (worst code I've ever written 🤠
#+BEGIN_SRC jupyter-python :session mast-py :tangle q47warui.py
  random.seed(4)
  twod_list = [list(random.randint(0,10) for _ in range(10)) for _ in range(4)]
  get_range_rows = lambda l: sorted(new_list,reverse=True)[0] - sorted(new_list)[0]
  normalise_2d_rows = lambda l: [ [l[row_idx][col_idx]/get_range_rows(row) for col_idx in range(len(row))] for row_idx, row in enumerate(l) ]
  get_range_cols = lambda matrix: (num_rows := len(matrix),
				   num_cols := len(matrix[0]),
				   [max(row[col_idx] for row in matrix) - min(row[col_idx] for row in matrix) for col_idx in range(num_cols)])[-1]
  normalise_2d_cols = lambda l: [ [(l[row_idx][col_idx]-min(row[col_idx] for row in l))/(get_range_cols(l))[col_idx] for col_idx in range(len(row))] for row_idx, row in enumerate(l) ]

  print(twod_list)
  print(get_range_cols(twod_list))
  #print(sorted(twod_list,reverse=True))
  #print(normalise_2d_rows(twod_list))
  print(normalise_2d_cols(twod_list))
#+END_SRC

#+RESULTS:
: [[3, 4, 1, 6, 7, 2, 1, 1, 0, 6], [8, 4, 0, 3, 8, 8, 5, 4, 2, 1], [4, 3, 0, 10, 4, 4, 3, 2, 4, 4], [10, 5, 1, 9, 5, 10, 6, 8, 3, 2]]
: [7, 2, 1, 7, 4, 8, 5, 7, 4, 5]
: [[0.0, 0.5, 1.0, 0.42857142857142855, 0.75, 0.0, 0.0, 0.0, 0.0, 1.0], [0.7142857142857143, 0.5, 0.0, 0.0, 1.0, 0.75, 0.8, 0.42857142857142855, 0.5, 0.0], [0.14285714285714285, 0.0, 0.0, 1.0, 0.0, 0.25, 0.4, 0.14285714285714285, 1.0, 0.6], [1.0, 1.0, 1.0, 0.8571428571428571, 0.25, 1.0, 1.0, 1.0, 0.75, 0.2]]

*** soln (official)
#+BEGIN_SRC jupyter-python :session mast-py :tangle q47official.py
import random
matrix = [[random.random() for _ in range(3)] for _ in range(3)]
min_col = [min(row[i] for row in matrix) for i in range(3)]
max_col = [max(row[i] for row in matrix) for i in range(3)]
normalized_matrix = [[(row[i] - min_col[i]) / (max_col[i] - min_col[i]) for i in range(3)] for row in matrix]
print(normalized_matrix)
#+END_SRC

** DONE Exercise 48:
CLOSED: [2025-03-26 Wed 22:06]
:LOGBOOK:
- State "DONE"       from              [2025-03-26 Wed 22:06]
:END:

Compute the cumulative sum of elements along a given axis in a 2D list.

*** soln
#+BEGIN_SRC jupyter-python :session mast-py :tangle q48.py
  cum_sum = lambda l, axis: [ [sum(l[row_idx][:col_idx+1]) for col_idx in range(len(row)) ] for row_idx, row in enumerate(l) ]
  print(twod_list)
  print(cum_sum(twod_list, 0))
  cum_sum_lambda = lambda l, axis: (
    [
	[sum(col[0:row_idx+1]) for row_idx in range(len(col))]
	for col in zip(*l)
    ] if axis == 0 else [
	[sum(row[0:col_idx+1]) for col_idx in range(len(row))]
	for row in l
    ]
  )
  print(cum_sum_lambda(twod_list, 0))
  print(cum_sum_lambda(twod_list, 1))
#+END_SRC

#+RESULTS:
: [[3, 4, 1, 6, 7, 2, 1, 1, 0, 6], [8, 4, 0, 3, 8, 8, 5, 4, 2, 1], [4, 3, 0, 10, 4, 4, 3, 2, 4, 4], [10, 5, 1, 9, 5, 10, 6, 8, 3, 2]]
: [[3, 7, 8, 14, 21, 23, 24, 25, 25, 31], [8, 12, 12, 15, 23, 31, 36, 40, 42, 43], [4, 7, 7, 17, 21, 25, 28, 30, 34, 38], [10, 15, 16, 25, 30, 40, 46, 54, 57, 59]]
: [[3, 11, 15, 25], [4, 8, 11, 16], [1, 1, 1, 2], [6, 9, 19, 28], [7, 15, 19, 24], [2, 10, 14, 24], [1, 6, 9, 15], [1, 5, 7, 15], [0, 2, 6, 9], [6, 7, 11, 13]]
: [[3, 7, 8, 14, 21, 23, 24, 25, 25, 31], [8, 12, 12, 15, 23, 31, 36, 40, 42, 43], [4, 7, 7, 17, 21, 25, 28, 30, 34, 38], [10, 15, 16, 25, 30, 40, 46, 54, 57, 59]]

** DONE Exercise 49:
CLOSED: [2025-03-26 Wed 22:05]
:LOGBOOK:
- State "DONE"       from              [2025-03-26 Wed 22:05]
:END:

Check if any element in a list is non-zero.

*** soln
#+BEGIN_SRC jupyter-python :session mast-py :tangle q49.py
  non_zero = lambda l: any(l)
  print(non_zero(twod_list[0]))
#+END_SRC

#+RESULTS:
: True
: [[3, 4, 1, 6, 7, 2, 1, 1, 0, 6], [8, 4, 0, 3, 8, 8, 5, 4, 2, 1], [4, 3, 0, 10, 4, 4, 3, 2, 4, 4], [10, 5, 1, 9, 5, 10, 6, 8, 3, 2]]

** DONE Exercise 50:
CLOSED: [2025-03-26 Wed 22:05]
:LOGBOOK:
- State "DONE"       from              [2025-03-26 Wed 22:05]
:END:

Create a 2D list with random integers and replace all values greater than a certain threshold with that threshold.

*** soln
#+BEGIN_SRC jupyter-python :session mast-py :tangle q50.py
  threshold_replace = lambda l, t: [ [ t if l[row_idx][col_idx] > t else l[row_idx][col_idx] for col_idx in range(len(row)) ] for row_idx, row in enumerate(l) ]
  print(threshold_replace(twod_list, 5))
#+END_SRC

#+RESULTS:
: [[3, 4, 1, 5, 5, 2, 1, 1, 0, 5], [5, 4, 0, 3, 5, 5, 5, 4, 2, 1], [4, 3, 0, 5, 4, 4, 3, 2, 4, 4], [5, 5, 1, 5, 5, 5, 5, 5, 3, 2]]

** DONE Exercise 51:
CLOSED: [2025-03-30 Sun 22:58]
:LOGBOOK:
- State "DONE"       from              [2025-03-30 Sun 22:58]
:END:

Find the median of a list of numbers.

*** soln

#+BEGIN_SRC jupyter-python :session mast-py :tangle q51.py
  import random
  random.seed()
  list_nums = [random.randint(0,5) for _ in range(5)]
  median = lambda l: l[len(l) / 2 if len(l) % 2 == 0 else len(l)//2 ]
  print(list_nums)
  print(median(list_nums))
#+END_SRC

#+RESULTS:
: [5, 5, 2, 5, 3]
: 2

** DONE Exercise 52:
CLOSED: [2025-03-30 Sun 22:58]
:LOGBOOK:
- State "DONE"       from              [2025-03-30 Sun 22:58]
:END:

Convert a list of numbers to a list of their logarithms.

*** soln

#+BEGIN_SRC jupyter-python :session mast-py :tangle q52.py
  import math
  log_list = lambda l: [math.log(x) for x in l]
  print(log_list(list_nums))
#+END_SRC

#+RESULTS:
: [1.6094379124341003, 1.6094379124341003, 0.6931471805599453, 1.6094379124341003, 1.0986122886681098]

** DONE Exercise 53:
CLOSED: [2025-03-30 Sun 22:58]
:LOGBOOK:
- State "DONE"       from              [2025-03-30 Sun 22:58]
:END:

Find the mode of a list of numbers.

*** soln

disclaimer: this implementation does not deal with *multiple* most often occurring values
#+BEGIN_SRC jupyter-python :session mast-py :tangle q53.py
  list_nums = [random.randint(0,5) for _ in range(5)]
  def mode(l):
    uniques = set(l)
    mo = (0,) # most often
    for x in uniques:
      y = l.count(x)
      if y > mo[0]:
	mo = (y, x)
    return mo[1]
  print(list_nums)
  print(mode(list_nums))
#+END_SRC

#+RESULTS:
: [5, 3, 5, 1, 1]
: 1

** DONE Exercise 54:
CLOSED: [2025-03-30 Sun 22:58]
:LOGBOOK:
- State "DONE"       from              [2025-03-30 Sun 22:58]
:END:

Flatten a list of lists.

*** soln

#+BEGIN_SRC jupyter-python :session mast-py :tangle q54.py
  nested_list = [[ [ random.randint(0,4) for _ in range(4) ] for _ in range(3) ] for _ in range(2) ]
  twod_nested_list = [ [ random.randint(0,4) for _ in range(4) ] for _ in range(3) ]
  print(nested_list)
  unwrap_2d = lambda l: [x for rows in l for x in rows]
  print(unwrap_2d(twod_nested_list))
  print(nested_list)
  unwrap_3d = lambda l: [x for matrices in l for rows in matrices for x in rows]
  print(unwrap_3d(nested_list))
#+END_SRC

#+RESULTS:
: [[[4, 0, 1, 2], [2, 0, 4, 0], [3, 0, 0, 0]], [[3, 4, 1, 4], [1, 3, 4, 1], [0, 4, 0, 4]]]
: [2, 0, 4, 3, 0, 0, 0, 0, 0, 3, 0, 3]
: [[[4, 0, 1, 2], [2, 0, 4, 0], [3, 0, 0, 0]], [[3, 4, 1, 4], [1, 3, 4, 1], [0, 4, 0, 4]]]
: [4, 0, 1, 2, 2, 0, 4, 0, 3, 0, 0, 0, 3, 4, 1, 4, 1, 3, 4, 1, 0, 4, 0, 4]

** DONE Exercise 55:
CLOSED: [2025-03-30 Sun 22:58]
:LOGBOOK:
- State "DONE"       from              [2025-03-30 Sun 22:58]
:END:

Transpose a 2D list.
*** soln

#+BEGIN_SRC jupyter-python :session mast-py :tangle q55.py
  print(twod_nested_list)
  transpose = lambda l: [[ l[j][i] for j in range(len(l)) ] for i in range(len(l[0]))]
  print(transpose(twod_nested_list))
#+END_SRC

#+RESULTS:
: [[2, 0, 4, 3], [0, 0, 0, 0], [0, 3, 0, 3]]
: [[2, 0, 0], [0, 0, 3], [4, 0, 0], [3, 0, 3]]

** DONE Exercise 56:
CLOSED: [2025-04-02 Wed 00:44]
:LOGBOOK:
- State "DONE"       from              [2025-04-02 Wed 00:44]
:END:

Remove duplicates from a list while preserving order.
*** soln

#+BEGIN_SRC jupyter-python :session mast-py :tangle q56.py
  lst = [5,3,2,3,4,5,5,1,2,1,1]
  seen = set()
  print(set(lst)) # note that this orders things, that's all.
  unique_lst = [x for x in lst if not (x in seen or seen.add(x))] # i'm not grasping the seen.add(x) part.
  print(unique_lst)
#+END_SRC

#+RESULTS:
: {1, 2, 3, 4, 5}
: [5, 3, 2, 4, 1]

** DONE Exercise 57:
CLOSED: [2025-04-02 Wed 00:44]
:LOGBOOK:
- State "DONE"       from              [2025-04-02 Wed 00:44]
:END:

Find the intersection of two lists.
*** soln

#+BEGIN_SRC jupyter-python :session mast-py :tangle q57.py
  lst1 = [5,2,5,3,1,2]
  lst2 = [1,3,9,5,2]
  print(set(lst1).intersection(lst2))
  # turns out there's another way:
  print(set(lst1) & set(lst2))
#+END_SRC

#+RESULTS:
: {1, 2, 3, 5}
: {1, 2, 3, 5}

** DONE Exercise 58:
CLOSED: [2025-04-02 Wed 00:44]
:LOGBOOK:
- State "DONE"       from              [2025-04-02 Wed 00:44]
:END:

Merge two dictionaries.
*** soln

#+BEGIN_SRC jupyter-python :session mast-py :tangle q58.py
  dic1 = {'a': 1, 'c': 6}
  dic2 = {'d': 6, 'r': 2, 'l': 3}
  print(dic1 | dic2)
  # furthermore, there is
  print({**dic1, **dic2})
#+END_SRC

#+RESULTS:
: {'a': 1, 'c': 6, 'd': 6, 'r': 2, 'l': 3}
: {'a': 1, 'c': 6, 'd': 6, 'r': 2, 'l': 3}

** DONE Exercise 59:
CLOSED: [2025-04-02 Wed 00:44]
:LOGBOOK:
- State "DONE"       from              [2025-04-02 Wed 00:44]
:END:

Sort a list of dictionaries by a key.
*** soln

#+BEGIN_SRC jupyter-python :session mast-py :tangle q59wrong.py
  print(sorted(dic2.items(), key=lambda x:x[0])) # can sort on values with x[1]
#+END_SRC

#+RESULTS:
: [('d', 6), ('l', 3), ('r', 2)]

this is actually *not* what the question asked for. they asked for sorting on a /specific/ key from a /list of dicts/.

#+BEGIN_SRC jupyter-python :session mast-py :tangle q59wright.py
  lst = [{'name' : 'Alice', 'age': 10}, {'name':'Bob','age':15}, {'name':'Charlie','age':20}]
  print(sorted(lst, key=lambda x:x['age']))
#+END_SRC

#+RESULTS:
: [{'name': 'Alice', 'age': 10}, {'name': 'Bob', 'age': 15}, {'name': 'Charlie', 'age': 20}]

** DONE Exercise 60:
CLOSED: [2025-04-02 Wed 00:44]
:LOGBOOK:
- State "DONE"       from              [2025-04-02 Wed 00:44]
:END:

Filter a dictionary based on its values.

*** soln

#+BEGIN_SRC jupyter-python :session mast-py :tangle q60.py
  d = {'a': 1, 'b':2, 'c':3}
  filtered_dict = {k:v for k,v in d.items() if v > 1}
  print(filtered_dict)
#+END_SRC

#+RESULTS:
: {'b': 2, 'c': 3}

** DONE Exercise 61:
CLOSED: [2025-04-03 Thu 21:30]
:LOGBOOK:
- State "DONE"       from              [2025-04-03 Thu 21:30]
:END:

Create a dictionary from two lists.

*** soln

#+BEGIN_SRC jupyter-python :session mast-py :tangle q61.py
  keys = ['a','b','c','d']
  values = [1,2,3,4]
  joined_dict = dict(zip(keys,values))
  print(joined_dict)
#+END_SRC

#+RESULTS:
: {'a': 1, 'b': 2, 'c': 3, 'd': 4}

** DONE Exercise 62:
CLOSED: [2025-04-03 Thu 21:30]
:LOGBOOK:
- State "DONE"       from              [2025-04-03 Thu 21:30]
:END:

Find the maximum value in a dictionary.

*** soln

#+BEGIN_SRC jupyter-python :session mast-py :tangle q62.py
  print(max(joined_dict))
  print(max(joined_dict.items()))
  print(max(joined_dict.values()))
#+END_SRC

#+RESULTS:
: d
: ('d', 4)
: 4

** DONE Exercise 63:
CLOSED: [2025-04-03 Thu 21:30]
:LOGBOOK:
- State "DONE"       from              [2025-04-03 Thu 21:30]
:END:

Invert a dictionary (swap keys and values).

*** soln

#+BEGIN_SRC jupyter-python :session mast-py :tangle q63.py
  new_dict = {v:k for k,v in joined_dict.items()}
  print(new_dict)
#+END_SRC

#+RESULTS:
: {1: 'a', 2: 'b', 3: 'c', 4: 'd'}

** DONE Exercise 64:
CLOSED: [2025-04-03 Thu 21:30]
:LOGBOOK:
- State "DONE"       from              [2025-04-03 Thu 21:30]
:END:

Create a dictionary with a default value.

*** soln

#+BEGIN_SRC jupyter-python :session mast-py :tangle q64.py
  keys = ['x', 'y', 'z']
  v = 5
  mydict = {k:v for k in keys}
  print(mydict)
#+END_SRC

#+RESULTS:
: {'x': 5, 'y': 5, 'z': 5}

** DONE Exercise 65:
CLOSED: [2025-04-03 Thu 21:30]
:LOGBOOK:
- State "DONE"       from              [2025-04-03 Thu 21:30]
:END:

Convert a dictionary to a list of tuples.

*** soln

#+BEGIN_SRC jupyter-python :session mast-py :tangle q65.py
  ts = [item for item in mydict.items()]
  # the above is probably a little slower than:
  ts_fast = list(mydict.items()) # note that [] is different here than to list.
  print(ts_fast)
#+END_SRC

#+RESULTS:
: [('x', 5), ('y', 5), ('z', 5)]

*** list comparison aside

#+BEGIN_SRC jupyter-python :session mast-py :tangle list-notation.py
  # [] is different to list(). [] is a literal, whereas list() is a constructor
  # [] is bytecode, list() requires a function call
  import timeit
  print(timeit.timeit("[]", number=10**6)) # faster
  print(timeit.timeit("list()", number=10**6)) # slower
  # list() is more versatile and can convert iterables into lists
  # [] can only define new lists.
#+END_SRC

#+RESULTS:
: 0.0166785828769207
: 0.034710833337157965

** DONE Exercise 66:
CLOSED: [2025-04-03 Thu 21:30]
:LOGBOOK:
- State "DONE"       from              [2025-04-03 Thu 21:30]
:END:

Find the length of the longest string in a list.

*** soln

#+BEGIN_SRC jupyter-python :session mast-py :tangle q66.py
  strings = ["my", "cartridge", "got", "hitroadige", "by", "a", "truck"]
  print(max(strings)) # alphabetised
  print(max(strings, key=lambda x: len(x)))
#+END_SRC

#+RESULTS:
: truck
: hitroadige

** DONE Exercise 67:
CLOSED: [2025-04-03 Thu 21:30]
:LOGBOOK:
- State "DONE"       from              [2025-04-03 Thu 21:30]
:END:

Reverse the words in a sentence.

*** soln

#+BEGIN_SRC jupyter-python :session mast-py :tangle q67.py
  s = "oh my god, I might fail this course"
  list_of_words = s.split()
  print(' '.join(list_of_words[::-1]))
#+END_SRC

#+RESULTS:
: course this fail might I god, my oh

** DONE Exercise 68:
CLOSED: [2025-04-03 Thu 21:30]
:LOGBOOK:
- State "DONE"       from              [2025-04-03 Thu 21:30]
:END:

Check if a string is a palindrome.

*** soln

#+BEGIN_SRC jupyter-python :session mast-py :tangle q68.py
  palindrome_checker = lambda s: True if s==s[::-1] else False
  print(palindrome_checker("lick"))
  print(palindrome_checker("kayak"))
#+END_SRC

#+RESULTS:
: False
: True

** DONE Exercise 69:
CLOSED: [2025-04-03 Thu 21:30]
:LOGBOOK:
- State "DONE"       from              [2025-04-03 Thu 21:30]
:END:

Remove punctuation from a string.

*** soln

#+BEGIN_SRC jupyter-python :session mast-py :tangle q69.py
  import string
  remove_punc = lambda s: s.translate(str.maketrans('','',string.punctuation))
  print(remove_punc("remove, punc? punk!"))
#+END_SRC

#+RESULTS:
: remove punc punk

** DONE Exercise 70:
CLOSED: [2025-04-03 Thu 21:30]
:LOGBOOK:
- State "DONE"       from              [2025-04-03 Thu 21:30]
:END:

Count the occurrences of each character in a string.

*** soln

#+BEGIN_SRC jupyter-python :session mast-py :tangle q70.py
  print(s)
  count_chars = lambda s: {char: s.count(char) for char in set(s)}
  print(sorted(list(count_chars(s).items()), key=lambda x:x[1]))
#+END_SRC

#+RESULTS:
: oh my god, I might fail this course
: [('f', 1), ('y', 1), ('l', 1), ('d', 1), ('r', 1), ('u', 1), (',', 1), ('I', 1), ('a', 1), ('c', 1), ('e', 1), ('g', 2), ('s', 2), ('m', 2), ('t', 2), ('h', 3), ('i', 3), ('o', 3), (' ', 7)]

** Exercise 71:

Find the longest common prefix among a list of strings.

*** soln

#+BEGIN_SRC jupyter-python :session mast-py :tangle q71.py

#+END_SRC

** Exercise 72:

Convert a string to a list of characters.

*** soln

#+BEGIN_SRC jupyter-python :session mast-py :tangle q72.py

#+END_SRC


** Exercise 73:

Generate a list of random integers.

*** soln

#+BEGIN_SRC jupyter-python :session mast-py :tangle q73.py

#+END_SRC


** Exercise 74:

Shuffle a list.

*** soln

#+BEGIN_SRC jupyter-python :session mast-py :tangle q74.py

#+END_SRC


** Exercise 75:

Generate a random password of a given length.

*** soln

#+BEGIN_SRC jupyter-python :session mast-py :tangle q75.py

#+END_SRC


** Exercise 76:

Calculate the factorial of a number.

*** soln

#+BEGIN_SRC jupyter-python :session mast-py :tangle q76.py

#+END_SRC


** Exercise 77:

Calculate the Fibonacci sequence up to a given number of terms.

*** soln

#+BEGIN_SRC jupyter-python :session mast-py :tangle q76.py

#+END_SRC


** Exercise 78:

Check if a number is prime.

*** soln

#+BEGIN_SRC jupyter-python :session mast-py :tangle q77.py

#+END_SRC


** Exercise 79:

Find the greatest common divisor (GCD) of two numbers.

*** soln

#+BEGIN_SRC jupyter-python :session mast-py :tangle q79.py

#+END_SRC


** Exercise 80:

Find the least common multiple (LCM) of two numbers.

*** soln

#+BEGIN_SRC jupyter-python :session mast-py :tangle q80.py

#+END_SRC


** Exercise 81:

Sort a list of tuples by the second element.

*** soln

#+BEGIN_SRC jupyter-python :session mast-py :tangle q81.py

#+END_SRC


** Exercise 82:

Find the second largest number in a list.

*** soln

#+BEGIN_SRC jupyter-python :session mast-py :tangle q82.py

#+END_SRC


** Exercise 83:

Check if a list is a palindrome.

*** soln

#+BEGIN_SRC jupyter-python :session mast-py :tangle q83.py

#+END_SRC


** Exercise 84:

Find the sum of the digits of a number.

*** soln

#+BEGIN_SRC jupyter-python :session mast-py :tangle q84.py

#+END_SRC


** Exercise 85:

Find the product of the digits of a number.

*** soln

#+BEGIN_SRC jupyter-python :session mast-py :tangle q85.py

#+END_SRC


** Exercise 86:

Check if a string is a valid number.

*** soln

#+BEGIN_SRC jupyter-python :session mast-py :tangle q86.py

#+END_SRC


** Exercise 87:

Find the length of the longest word in a sentence.

*** soln

#+BEGIN_SRC jupyter-python :session mast-py :tangle q87.py

#+END_SRC


** Exercise 88:

Convert a list of tuples to a dictionary.

*** soln

#+BEGIN_SRC jupyter-python :session mast-py :tangle q88.py

#+END_SRC


** Exercise 89:

Filter a list of dictionaries based on a key value.

*** soln

#+BEGIN_SRC jupyter-python :session mast-py :tangle q89.py

#+END_SRC


** Exercise 90:

Sort a list of tuples by multiple keys.

*** soln

#+BEGIN_SRC jupyter-python :session mast-py :tangle q90.py

#+END_SRC


** Exercise 91:

Merge two lists into a dictionary, using one as keys and the other as values.

*** soln

#+BEGIN_SRC jupyter-python :session mast-py :tangle q91.py

#+END_SRC

** Exercise 92:

Create a dictionary with keys as numbers and values as their squares.

*** soln

#+BEGIN_SRC jupyter-python :session mast-py :tangle q92.py

#+END_SRC


** Exercise 93:

Check if two strings are anagrams.

*** soln

#+BEGIN_SRC jupyter-python :session mast-py :tangle q93.py

#+END_SRC


** Exercise 94:

Count the number of vowels in a string.

*** soln

#+BEGIN_SRC jupyter-python :session mast-py :tangle q94.py

#+END_SRC


** Exercise 95:

Check if a string contains only digits.

*** soln

#+BEGIN_SRC jupyter-python :session mast-py :tangle q95.py

#+END_SRC

** Exercise 96:

Find the first non-repeated character in a string.

*** soln

#+BEGIN_SRC jupyter-python :session mast-py :tangle q96.py

#+END_SRC


** Exercise 97:

Reverse each word in a sentence.

*** soln

#+BEGIN_SRC jupyter-python :session mast-py :tangle q97.py

#+END_SRC


** Exercise 98:

Generate a list of Fibonacci numbers up to a given number.

*** soln

#+BEGIN_SRC jupyter-python :session mast-py :tangle q98.py

#+END_SRC


** Exercise 99:

Remove all whitespaces from a string.

*** soln

#+BEGIN_SRC jupyter-python :session mast-py :tangle q99.py

#+END_SRC


** Exercise 100:

Replace all occurrences of a substring in a string.

*** soln

#+BEGIN_SRC jupyter-python :session mast-py :tangle q100.py

#+END_SRC
