+++
title = "what"
tags = ["classes", "inheritance"]
tikzajax = "true"
+++

# comment: I am using the old math-definition boxes on this page. whilst this means I cannot nest shortcodes, I can use the org-markdown freely.

#+BEGIN_EXPORT html
<style>
/* Scope to any ancestor whose class list has a token starting with "math-" */
:where([class^="math-"], [class*=" math-"])
  :is(
    code.verbatim,
    code[class^="language-"],
    code[class*=" language-"],
    pre[class^="language-"],
    pre[class*=" language-"]
  ) {
  background: var(--bg2) !important;
}

/* Optional: make inline backgrounds look nicer */
:where([class^="math-"], [class*=" math-"]) code {
  padding: .1em .25em;
  border-radius: .25em;
}
</style>

<script>
document.addEventListener('DOMContentLoaded', () => {
  document.querySelectorAll('div.src-inline').forEach(wrapper => {
    const code = wrapper.querySelector('code[class*="language-"]');
    if (!code) return;

    // If the wrapper had the only math-* class, move it up to the parent
    const mathClasses = [...wrapper.classList].filter(c => c.startsWith('math-'));
    if (mathClasses.length && wrapper.parentElement) {
      const parent = wrapper.parentElement;
      const parentHasMath = [...parent.classList].some(c => c.startsWith('math-'));
      if (!parentHasMath) parent.classList.add(...mathClasses);
    }

    // Replace wrapper with the code element
    wrapper.replaceWith(code);
  });
});
</script>

#+END_EXPORT

** notes

this page could be a lot more -- largely because of the huge power of Object-Oriented-Programming.

instead I have chosen to limit the scope of this page to simple definitions

{{< mdef "Data" >}}
Ultimately, programming is about taking some data and then manipulating it. Either in-place or manipulating other data in another place.

This is why Object-Oriented-Programming is so powerful: because it encapsulates the data with the methods which manipulate it:

#+BEGIN_SRC java
public class Circle extends Object {
  // data:
  private static final double PI = 3.14159;
  public int x = 0, y = 0;
  private int r = 6;
  static int no_circles = 0;

  // constructors:
  public Circle() { super(); no_circles++; }
  public Circle(int x, int y, int r) { this(); this.x=x; this.y=y; this.r=r; }
  public Circle(int x, int y) { this(x,y,5); }

  // methods:
  public double getArea() { return PI * r * r; }

  @Override public String toString() {
    return "[" + x + ", " + y + " r=" + r + "]";
  }

  @Override public boolean equals(Object obj) {
    if (obj == this) return true;
    if (!(obj instanceof Circle other)) return false;
    return x==other.x && y==other.y && r==other.r;
  }

  // Getters/Setters
  public int getR(){ return r; }
  public void setR(int r){ if(r>0) this.r=r; }
}
#+END_SRC
{{< /mdef >}}

{{< mdef "Object" >}}
An object is an instance of a class. Create with src_java[:exports code]{Animal lion = new Animal()}, where =lion= is the variable, =Animal= is the type, and =Animal()= is the constructor.
{{< /mdef >}}

{{< mdef "Class" >}}
A blueprint bundling state (fields) and behaviour (methods). Models “types” in your domain and enforces invariants via visibility and constructors.
{{< /mdef >}}

{{< mdef "Sub-classes" >}}
A subclass extends a superclass, inheriting accessible fields/methods and possibly overriding behaviour. Use when “is-a” holds and LSP is preserved.

#+BEGIN_SRC java
class Animal { void speak(){ System.out.println("..."); } }
class Dog extends Animal { @Override void speak(){ System.out.println("woof"); } }
#+END_SRC
{{< /mdef >}}

{{< mdef "Inheritance" >}}
Code reuse via “is-a”. Pros: shared behaviour, polymorphism. Cons: tight coupling, fragile base-class, awkward evolution. Prefer shallow hierarchies and final where appropriate.
{{< /mdef >}}

{{< mdef "Composition" >}}
“Has-a”: build objects from parts, delegate behaviour. Favors encapsulation and changeability.

#+BEGIN_SRC java
class Engine { void start(){} }
class Car { private final Engine e = new Engine(); void start(){ e.start(); } }
#+END_SRC
{{< /mdef >}}

{{< mdef "Coupling" >}}
Degree of interdependence. Aim for low coupling & high cohesion. Symptoms of high coupling: many imports, reaching through objects (feature envy), brittle tests.
{{< /mdef >}}

{{< mdef "Design Patterns" >}}
Reusable templates for common forces/trade-offs.

- Creational: Factory Method, Abstract Factory, Builder, Prototype, Singleton (use sparingly).
- Structural: Adapter, Bridge, Composite, Decorator, Facade, Flyweight, Proxy.
- Behavioral: Strategy, Template Method, Observer, Command, Iterator, State, Visitor, Mediator, Memento, Chain of Responsibility.
{{< /mdef >}}

{{< mdef "Design Smells" >}}
Long method, Large/God class, Data clumps, Shotgun surgery, Feature envy, Primitive obsession, Circular deps, Inappropriate intimacy, Refused bequest, Long parameter list.
{{< /mdef >}}

{{< mdef "Refactoring" >}}
Small semantics-preserving steps to improve design: Extract Method/Class, Introduce Parameter Object, Replace Conditional with Polymorphism, Move Method/Field, Encapsulate Collection, Decompose Conditional, Inline Temp, Replace Inheritance with Delegation (and vice-versa).
{{< /mdef >}}

{{< mdef "Interfaces" >}}
Pure contracts (types without implementation/state). Enable multiple “roles”, test doubles, and interchangeability.

#+BEGIN_SRC java
interface PaymentGateway { boolean charge(long cents); }
class StripeGateway implements PaymentGateway { public boolean charge(long c){ return true; } }
#+END_SRC
{{< /mdef >}}

{{< mdef "Abstract Classes" >}}
Partial implementations with state and constructors; can define template methods and share code among subclasses.

#+BEGIN_SRC java
abstract class Shape {
  abstract double area();
  final double scaleTo(double k){ return k*k*area(); } // template utility
}
class Rect extends Shape { double w,h; Rect(double w,double h){this.w=w;this.h=h;} double area(){return w*h;} }
#+END_SRC
{{< /mdef >}}

{{< mdef "Polymorphism" >}}
Same message, different behaviour.

- Overloading (compile-time): same name, different signatures.
- Overriding (run-time): dynamic dispatch via actual type.
- LSP: Subtypes must be substitutable for their supertypes without breaking correctness.

#+BEGIN_SRC java
List<Shape> shapes = List.of(new Rect(2,3), new Rect(1,1));
double total = shapes.stream().mapToDouble(Shape::area).sum();
#+END_SRC
{{< /mdef >}}

{{< mdef "Design Heuristics" >}}
Prefer composition; program to interfaces; keep classes small & cohesive; make illegal states unrepresentable; push side-effects to edges; isolate infrastructure behind ports/adapters.
{{< /mdef >}}

{{< mdef "SOLID (quick)" >}}
S: one reason to change. O: open for extension, closed for modification. L: honor contracts. I: small, focused interfaces. D: depend on abstractions, not concretions.
{{< /mdef >}}

# TikZ sketches (kept outside definition boxes)



{{< tikztwo >}}
% Geometric representation of the sum 1 + 1/2 + 1/4 + 1/8 + ...
% Adapted to show convergence to 2
\usepackage{tikz}
\begin{document}
\begin{tikzpicture}[scale=.35]\footnotesize
 \pgfmathsetmacro{\xone}{-.4}
 \pgfmathsetmacro{\xtwo}{ 16.4}
 \pgfmathsetmacro{\yone}{-.4}
 \pgfmathsetmacro{\ytwo}{16.4}

\begin{scope}<+->;
% grid
  \draw[step=1cm,gray,very thin] (\xone,\yone) grid (\xtwo,\ytwo);

% ticks
  \foreach \x/\xtext in {8/1, 16/2}
  \draw[gray,xshift=\x cm] (0,.3) -- (0,0) node[below] {$\xtext$};
  \foreach \y/\ytext in {8/1, 16/2}
    \draw[gray, yshift=\y cm] (.3,0) -- (0,0)
    node[left] {$\ytext$};

% origin
 \draw[gray] (0,0) node[anchor=north east] {$O$};

% axes
  \draw[gray,thick,<->] (\xone, 0) -- (\xtwo, 0) node[right] {$x$};
  \draw[gray,thick,<->] (0, \yone) -- (0, \ytwo) node[above] {$y$};
\end{scope}

% function - building rectangles that sum to 2
\begin{scope}[thick,red]
  % Main square (represents 1)
  \filldraw[red,opacity=.3] (0, 0) rectangle (8,16);
  
  % Rectangle 1/2 (width 4, height 16)
  \filldraw[blue,opacity=.2] (8, 0) rectangle (12,16);
  
  % Rectangle 1/4 (width 2, height 16)
  \filldraw[green,opacity=.2] (12, 0) rectangle (14,16);
  
  % Rectangle 1/8 (width 1, height 16)
  \filldraw[orange,opacity=.2] (14, 0) rectangle (15,16);
  
  % Rectangle 1/16 (width 0.5, height 16)
  \filldraw[purple,opacity=.2] (15, 0) rectangle (15.5,16);
  
  % Rectangle 1/32 (width 0.25, height 16)
  \filldraw[cyan,opacity=.2] (15.5, 0) rectangle (15.75,16);
  
  % Rectangle 1/64 (width 0.125, height 16)
  \filldraw[magenta,opacity=.2] (15.75, 0) rectangle (15.875,16);

  % Outline the total area
  \draw[red,very thick] (0, 0) rectangle (16,16);
\end{scope}

% Add labels for each section
\node at (4,8) {$1$};
\node at (10,8) {$\frac{1}{2}$};
\node at (13,8) {$\frac{1}{4}$};
\node at (14.5,8) {\tiny$\frac{1}{8}$};

\end{tikzpicture}
\end{document}
{{< /tikztwo >}}


** references

1. https://docs.oracle.com/javase/tutorial/java/concepts/index.html  
2. Gamma et al., *Design Patterns*.  
3. Bloch, *Effective Java (3e)*.  
4. Fowler, *Refactoring (2e)*.  
5. Refactoring.Guru (catalog + smells).
