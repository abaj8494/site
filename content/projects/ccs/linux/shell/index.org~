+++
title = "Shell/s"
tags = ["bash", "sh", "fish", "zsh", "eshell"]
toc = "true"
math = "true"
+++

There are many shells, all of them do the same thing --- they allow you to manipulate your filesystem.

I have experience with all of the major shells excluding Powershell[fn:1]


I will create an org-mode document detailing the origins, uses, advantages, disadvantages, and capabilities of the following shells: Bash, sh, Fish, Zsh, and Eshell. Each section will be clearly separated by appropriate headings, and code snippets will be included using `+BEGIN_SRC shell` and `+END_SRC` for a technical audience. I will provide concise, informative explanations focusing on key differences and practical usage.

* Bash
** Origins  
Bash (Bourne Again SHell) was developed in 1989 by Brian Fox as part of the GNU Project ([Bash (Unix shell) - Wikipedia](https://en.wikipedia.org/wiki/Bash_(Unix_shell)#:~:text=In%20computing%20%2C%20Bash%20,9)). It was intended as a free replacement for the original Bourne shell (`sh`), incorporating features from other shells like the C shell and KornShell ([Bash (Unix shell) - Wikipedia](https://en.wikipedia.org/wiki/Bash_(Unix_shell)#:~:text=conventions%2C%20Bash%20incorporates%20a%20rich,compliant%20shell%20with%20extensions)). Over time, Chet Ramey became the primary maintainer, and Bash evolved into a robust, POSIX-compliant shell with many extensions.

** Uses  
Bash is the **de facto** shell on most Linux distributions and macOS (until recent versions) ([Bash (Unix shell) - Wikipedia](https://en.wikipedia.org/wiki/Bash_(Unix_shell)#:~:text=Since%20its%20inception%2C%20Bash%20has,tool%20in%20various%20computing%20environments)). It serves both as an interactive command-line interface for users and as a scripting language for automating tasks via shell scripts. System initialization scripts and user profile scripts (e.g. `~/.bashrc`) are often written in Bash. Its widespread availability makes it a common denominator for writing portable automation scripts and performing administrative tasks on Unix-like systems.

** Advantages  
- **Ubiquity and Compatibility:** Bash is installed by default on a wide range of systems, ensuring that Bash scripts can run in many environments without additional dependencies ([Bash (Unix shell) - Wikipedia](https://en.wikipedia.org/wiki/Bash_(Unix_shell)#:~:text=Since%20its%20inception%2C%20Bash%20has,tool%20in%20various%20computing%20environments)). It is largely backward-compatible with the Bourne shell, so POSIX `sh` scripts can usually run under Bash unmodified.  
- **Feature-Rich Scripting:** It supports structured programming constructs (loops, conditionals, functions) and data structures like indexed arrays (not present in pure Bourne shell). Bash also includes string manipulation, integer arithmetic, and associative arrays (in newer versions), enabling fairly complex scripting within the shell.  
- **Interactive Features:** Bash provides command history, command-line editing (via GNU Readline), and customizable prompts. It also supports job control (running processes in the background/foreground), and with additional frameworks (e.g. bash-completion), it can do context-aware tab completion.  
- **POSIX Compliance with Extensions:** Bash adheres to POSIX shell standards, which aids script portability, but also offers convenient extensions (e.g. brace expansion for generating sequences) beyond POSIX ([Bash (Unix shell) - Wikipedia](https://en.wikipedia.org/wiki/Bash_(Unix_shell)#:~:text=conventions%2C%20Bash%20incorporates%20a%20rich,compliant%20shell%20with%20extensions)).

** Disadvantages  
- **Limited User Friendliness by Default:** Out-of-the-box, Bash’s interactive experience is basic. It lacks modern niceties like automatic suggestions or syntax highlighting that newer shells (Fish or Zsh) provide. Users often must configure `~/.bashrc` or install additional tools for features like improved tab completion or colored prompts.  
- **Quirky Syntax and Pitfalls:** Bash inherited a lot of syntax from the original Bourne shell, which can be non-intuitive (for example, the heavy use of special characters, or subtle quoting rules). Mistakes with quoting or variable expansions can lead to hard-to-debug errors. The shell’s grammar has many corner cases, making it tricky for beginners.  
- **Performance in Complex Scripts:** While fine for moderate scripting, Bash is not optimized for large-scale software development. Large scripts can become slow and difficult to maintain. Also, each Bash subshell forks a process, which can make pipelines and command substitutions comparatively slower than in shells that avoid forking for certain operations.  
- **Platform Differences:** Bash versions can differ across systems (e.g., macOS shipped an older Bash 3.2 due to licensing, while Linux has 5.x), which can lead to inconsistencies in available features. Scripts using newer Bash-only features may not work on systems with older Bash, affecting portability.

** Capabilities  
Bash is a full-fledged programming environment for the command line. It can execute commands, launch programs, and glue together utilities with pipes. In scripting mode, it provides variables (scoped dynamically), arithmetic evaluation, arrays, and associative arrays. Bash can perform pattern matching and filename globbing, and it introduced brace expansion (e.g. `{01..10}` to generate sequences) to ease generating sets of arguments ([Bash (Unix shell) - Wikipedia](https://en.wikipedia.org/wiki/Bash_(Unix_shell)#:~:text=conventions%2C%20Bash%20incorporates%20a%20rich,compliant%20shell%20with%20extensions)). It also supports **here-documents** and **here-strings** for multiline input to commands, and process substitution for treating the output of a command as a file. For interactivity, Bash allows shell aliases, functions, and prompt customization (including command substitution in prompts). It is extensible via loadable builtins and can even interface with the system’s C library through commands like `printf` and `read`. 

+BEGIN_SRC shell  
# Bash script example: iterate over an array  
fruits=(apple banana cherry)  
for fruit in "${fruits[@]}"; do  
    echo "Fruit: $fruit"  
done  
+END_SRC

The above script uses a Bash-specific feature (indexed arrays) and a `for` loop to iterate through elements. This capability is not available in pure POSIX `sh`, demonstrating how Bash extends the Bourne shell with useful constructs.

** Limitations  
- **Portability Constraints:** Bash is larger and includes extensions beyond POSIX; if a script relies on Bash-specific features, it won’t run in strictly POSIX-compliant shells (like `/bin/sh` on some systems that use dash). Developers must sometimes explicitly invoke Bash (using `#!/usr/bin/env bash`) for scripts that need its features, and ensure target systems have Bash installed.  
- **No Native GUI or Graphics:** Bash is purely text-based. While it can call external programs (like `dialog` or `printf` to draw text UIs), it has no built-in capabilities for graphical interfaces or rich text display beyond what the terminal supports.  
- **Typing and Data Handling:** All data in Bash is essentially strings (there are no native data types beyond strings and integers for arithmetic). Floating-point arithmetic or complex data structures require external tools or programs. This limits Bash in applications requiring precise numeric computation or structured data manipulation.  
- **Concurrency and Safety:** Bash can launch background jobs easily, but managing concurrent processes (threading, synchronization) is not a built-in strength. Moreover, error handling is primitive (exit codes and traps); there’s no exception mechanism, so robust error propagation in large scripts is difficult. In critical systems scripting, these limitations mean Bash must be used with caution, or supplemented by more powerful languages when complexity grows.

* sh (Bourne Shell)
** Origins  
The **Bourne shell**, usually invoked as **`sh`**, was introduced by Stephen Bourne at Bell Labs and first appeared in Unix Version 7 (1979) ([Bourne shell - Wikipedia](https://en.wikipedia.org/wiki/Bourne_shell#:~:text=Work%20on%20the%20Bourne%20shell,considered%20to%20produce%20structured%20programs)) ([Bourne shell - Wikipedia](https://en.wikipedia.org/wiki/Bourne_shell#:~:text=The%20Bourne%20shell%20%28,are%20used%20by%20most%20users)). It replaced the earlier Thompson shell, and became the standard shell for UNIX systems in the late 1970s and 1980s. The Bourne shell’s design focused on scripting capability and introduced language features (like variables, control flow, and signal handling) to support writing structured shell programs ([Bourne shell - Wikipedia](https://en.wikipedia.org/wiki/Bourne_shell#:~:text=as%20a%20scripting%20language%20and,considered%20to%20produce%20structured%20programs)).

** Uses  
Historically, `/bin/sh` was the default login shell on UNIX. Today, “sh” usually refers to a POSIX-compliant shell (the language spec that evolved from the Bourne shell). It’s used for portability: many base system scripts (init scripts, maintenance scripts) are written to the POSIX `sh` standard so they can run on any Unix-like OS ([Bourne shell - Wikipedia](https://en.wikipedia.org/wiki/Bourne_shell#:~:text=The%20Bourne%20shell%20%28,are%20used%20by%20most%20users)). On modern Linux distributions, `/bin/sh` often links to a lightweight shell (like **dash** in Debian/Ubuntu) for faster script execution while still supporting POSIX syntax. In practice, developers use `sh` when they need maximum compatibility and minimal features – for example, writing install scripts or `Dockerfile` entrypoint scripts that must run in minimal environments.

** Advantages  
- **High Portability:** A script written in POSIX `sh` will run on virtually any Unix-like system, from Linux and BSD to commercial Unixes. This makes `sh` ideal for system bootstrap tasks and distribution-agnostic scripting.  
- **Low Resource Overhead:** The Bourne shell and its modern minimalist implementations (like dash) have a small footprint and start quickly. This is advantageous for systems that spawn many shell instances (e.g. boot sequences or process launchers).  
- **Simplicity:** The feature set of `sh` is small and straightforward. For scripting, it provides just the basics (variable assignment, loops, conditionals, simple expansions). This simplicity can be an advantage when trying to understand or audit shell scripts – there are fewer constructs to reason about compared to Bash or Zsh.  
- **Baseline for Other Shells:** Since Bash, Zsh, and others are generally backwards-compatible with `sh`, knowledge of Bourne shell syntax translates directly to those shells. It’s the common denominator, so learning `sh` constructs provides a foundation for using other shells.

** Disadvantages  
- **Limited Interactive Use:** The traditional Bourne shell lacks many conveniences for interactive use. For example, the original `sh` had no command history or line editing – every typo had to be retyped from scratch. Modern `sh` (like dash) still doesn’t support interactive niceties like completion or persistent history. Thus, `sh` is rarely used as an everyday interactive shell by users.  
- **Lack of Advanced Features:** Many features taken for granted in Bash/Zsh are absent in pure `sh`. There are no arrays, no associative arrays, and only very limited parameter expansion features. Shell arithmetic is minimal (often one must use external commands like `expr` for math in pure Bourne shell). These limitations mean complex scripting tasks are cumbersome in `sh`, requiring external utilities for functionality that Bash could do internally.  
- **Inconsistent Implementations:** While POSIX defines the `sh` language, actual `/bin/sh` implementations vary. Some systems’ `sh` might be Bash in POSIX mode, others might be dash or ksh. Small differences (e.g. in the `echo` command or local variables) can trip up scripts that assume a certain implementation. This inconsistency can be a disadvantage if a script inadvertently uses a non-standard extension.  
- **No Extensions or Plugins:** Unlike more modern shells, `sh` typically cannot be easily extended. One cannot load modules or use shell frameworks; if a functionality isn't provided by built-in or external commands, you must code around it manually.

** Capabilities  
As a language, `sh` provides core shell capabilities: running programs, I/O redirection (`>`, `<`, pipes), and fundamental flow control (`if...then`, `for` and `while` loops, case statements). It supports command substitution (`` `...` `` or `$(...)`) to use the output of one command in another, and simplistic wildcard globbing for filenames. Environment management is a strength – `sh` can launch other programs with adjusted environment variables and is often used to glue programs together. Bourne shell scripts often leverage Unix utilities heavily: since the shell itself has few built-ins for string manipulation or math, scripts call tools like `grep`, `cut`, `sed`, `awk`, and so on as part of their logic. This philosophy of composing small tools means `sh` acts as the glue in many automation scenarios. Modern POSIX `sh` has some enhancements over the 1970s version (for example, the `$(( ))` arithmetic expansion and the `$(command)` substitution for clarity).

+BEGIN_SRC shell  
# POSIX sh example: iterate over script arguments  
echo "Script name: $0"  
for arg in "$@"; do  
    echo "Argument: $arg"  
done  
+END_SRC

The above script uses Bourne shell syntax to loop over all command-line arguments (`$@`). It illustrates `sh` shell basics: a `for` loop, positional parameters, and simple variable expansion. This script would run in any POSIX-compliant shell, including Bash, dash, or others in `sh` mode.

** Limitations  
- **No Array Data Type:** There is no concept of arrays in pure `sh`. All variables are scalars (strings). This means tasks like storing a list of values require workarounds (such as storing values in a single string and splitting) and are error-prone.  
- **Primitive Error Handling:** The Bourne shell has no exception handling or try-catch; error handling is done by checking exit codes (`$?`) and using conditional commands like `||` and `&&` or traps. This makes writing robust, large scripts difficult compared to more modern scripting languages.  
- **Lack of Interactive Features:** As noted, `sh` in interactive mode is very bare-bones. Even if some implementations allow line editing (via `set -o emacs` or `vi` for example), it’s nowhere near the feature set of interactive shells like Bash, Zsh, or Fish.  
- **Not User-Oriented:** In contemporary use, `sh` is almost exclusively a scripting target rather than a user’s login shell. It’s designed for batch processing of commands. Real-world usage of `sh` is thus limited to non-interactive contexts (running scripts, cron jobs, system startup), and it’s generally bypassed by users in favor of more featureful shells for day-to-day command line work.

* Fish
** Origins  
**Fish**, short for “Friendly Interactive Shell,” was first released in 2005 by Axel Liljencrantz ([Fish (Unix shell) - Wikipedia](https://en.wikipedia.org/wiki/Fish_(Unix_shell)#:~:text=Original%20author,13%29%20Stable%20release)). It was created as a modern shell focused on user-friendliness and out-of-the-box experience, rather than strict POSIX compliance. Fish is open-source (GPL-2.0) and has been actively developed by a community of contributors; it deliberately chooses a design that does **not** follow all POSIX shell conventions, allowing it to introduce a more consistent and discoverable syntax and features ([Fish (Unix shell) - Wikipedia](https://en.wikipedia.org/wiki/Fish_(Unix_shell)#:~:text=Fish%20,6)).

** Uses  
Fish is primarily used as an interactive shell for users who want a more convenient command line experience. Developers and system administrators might switch their login shell to fish to take advantage of its features while typing commands manually. Its focus on interactivity means Fish is less commonly used for writing system scripts or in server automation (where Bash or sh is preferred for compatibility). However, fish scripts can be written for personal or team use if all systems that run them have fish installed. Real-world applications of fish include improved productivity in terminal sessions, live command-line demonstrations (because of its visual aids), and as a default shell in user environments where its unique syntax is acceptable. Fish runs on Linux, macOS, and other Unix-like systems, but since it isn’t usually pre-installed, users enable it for themselves when desired.

** Advantages  
- **User-Friendly Interface:** Fish provides a modern command-line UI with features like syntax highlighting, **autosuggestions** as you type, and visible right-side prompts with information. These features are available by default, without needing complex configuration, making the shell feel intelligent and helpful for new users ([The fish Shell | Object Computing, Inc.](https://objectcomputing.com/resources/publications/sett/november-2017-sett-article-fish-shell#:~:text=%2A%20colorful%20prompts%20%2A%20auto,special%20syntax%20to%20be%20memorized)).  
- **Powerful Autocompletion:** The shell comes with comprehensive tab-completion for commands and their options, file paths, variables, git branches, etc., often with descriptive help text. Fish can even parse man pages to suggest options, reducing the need to remember command flags ([Fish (Unix shell) - Wikipedia](https://en.wikipedia.org/wiki/Fish_(Unix_shell)#:~:text=Fish%20displays%20incremental%20suggestions%20,7)).  
- **Consistency and Discoverability:** Fish’s scripting syntax is designed to be consistent and avoid historical quirks. For example, everything is a command rather than having lots of special-case syntax. This means instead of tricky syntax or punctuation, you use straightforward commands (`set` for variables, `function`...`end` for functions) ([The fish Shell | Object Computing, Inc.](https://objectcomputing.com/resources/publications/sett/november-2017-sett-article-fish-shell#:~:text=,such%20as%20setting)). The maintainers chose clarity over POSIX compatibility, so common pitfalls of Bash (like test brackets or quoting issues) are largely eliminated or made more transparent.  
- **Out-of-the-Box Features:** Fish includes useful features without additional plugins: a configurable prompt with VCS (git) status, a universal variables system (to share variables across shell sessions), and even a web-based configuration interface for changing colors or prompts easily ([The fish Shell | Object Computing, Inc.](https://objectcomputing.com/resources/publications/sett/november-2017-sett-article-fish-shell#:~:text=%2A%20auto,such%20as%20setting)). It also provides helpful error messages that explain what's wrong in a command and even suggest corrections, which is very handy when writing or testing commands ([The fish Shell | Object Computing, Inc.](https://objectcomputing.com/resources/publications/sett/november-2017-sett-article-fish-shell#:~:text=,special%20syntax%20to%20be%20memorized)).  
- **No Unintended Subshell Behavior:** In Fish, each command in a pipeline runs in the current shell process where possible, rather than spawning subshells that forget state. As a result, if one command in a pipeline sets a variable or changes directory, that change can persist in fish (this is different from Bash, where each part of a pipeline runs in a subshell, losing state) ([The fish Shell | Object Computing, Inc.](https://objectcomputing.com/resources/publications/sett/november-2017-sett-article-fish-shell#:~:text=with%20commands%2C%20not%20special%20syntax,universal%20variables)). This design simplifies certain scripting patterns.

** Disadvantages  
- **Not POSIX Compliant:** Fish cannot run scripts written for POSIX shells without modification. Its syntax (e.g. `set var value` instead of `var=value`, different `if` syntax, etc.) is unique. This means fish scripts are fish-only, and many existing shell scripts (which assume Bourne-style syntax) won’t work in fish ([Fish (Unix shell) - Wikipedia](https://en.wikipedia.org/wiki/Fish_(Unix_shell)#:~:text=like%20shell%20%20with%20a,6)). This limits fish’s use in scripting for heterogeneous environments.  
- **Smaller Ecosystem:** Compared to Bash and Zsh, fish has a smaller user community and fewer available pre-existing scripts or frameworks. While it has a growing set of configuration tools and some plugins (via frameworks like Oh My Fish), it’s not as extensive as the plugin ecosystems of Zsh.  
- **Learning Curve for Scripting:** While interactive use is intuitive, writing fish scripts requires learning fish-specific syntax and semantics. Experienced Bash/Zsh users must adjust habits (for example, using `set` and `function` keywords, different quoting rules, etc.). This can be a barrier for teams if not everyone is familiar with fish.  
- **Requires Installation:** Fish is not typically included by default on many systems. Using it might require manual installation and changing the user’s login shell. In environments where you don’t have permission to install new shells (or on minimal rescue systems), fish won’t be available, so one must fall back to sh or Bash in those cases.  
- **Scripting Limitations:** Some advanced shell scripting features or edge cases might not be supported in fish (for example, fish doesn’t support `$LINENO` or `DEBUG` traps like Bash does). Also, certain shell idioms (like `alias | grep something` to find an alias) may not directly translate due to fish’s different command set (`alias` is a function in fish, not just a textual substitution).

** Capabilities  
Fish excels at interactive capabilities. It highlights the syntax as you type, detecting errors (e.g., missing quotes or brackets) in real time. Its autosuggestion feature remembers commands from your history and suggests completions (grayed out) that you can accept with the right arrow key ([Fish (Unix shell) - Wikipedia](https://en.wikipedia.org/wiki/Fish_(Unix_shell)#:~:text=Fish%20displays%20incremental%20suggestions%20,7)). Tab-completion in fish is context-aware and verbose: pressing Tab not only completes the command or filename but also lists possible options with brief descriptions. Scripting in fish uses a more verbose but readable style: for example, `if` statements require an explicit `end` to terminate the block, and variables are always set using the `set` command. Fish supports lists (arrays) inherently — a variable can hold multiple values, and you use `set var value1 value2 ...` to define them. Pipeline behavior is modified such that each segment of a pipeline can affect the current shell (useful for setting variables via commands). It also has some unique features like **universal variables** (with the `set -U` flag) which are shared across all fish sessions for that user, and it can import foreign environment variables but encourages using its own configuration files (`~/.config/fish/config.fish` instead of `~/.bashrc`).  

+BEGIN_SRC shell  
# Fish shell example: setting a variable and defining a function  
set fish_var "Hello, Fish!"       # assign a variable  
echo $fish_var                   # expand and print the variable  
function greet                   # define a new function  
    echo "Welcome to Fish shell!"  
end  
greet                            # call the function  
+END_SRC

In this snippet, note the differences from Bash syntax: `set` is used to assign `fish_var` (no `$` on the left side), and the function is defined with the `function` keyword and terminated with `end` instead of curly braces. These illustrate fish’s more structured, keywords-based syntax. Running this in fish would print the variable’s value and then execute the custom `greet` function.

** Limitations  
- **No Bash/Zsh Compatibility Mode:** Fish cannot easily emulate POSIX mode. This is a deliberate design choice but means it’s isolated in terms of scripting; one cannot simply change a shebang to `#!/usr/bin/fish` for a script that was written in Bash syntax. This limits fish’s role as a drop-in replacement in scripts – it’s mainly for interactive use or fish-specific scripts.  
- **Performance Overheads:** While fish is reasonably fast for interactive use, some users have noted that its advanced features (like parsing man pages for completions) can make it slightly heavier or slower to start up compared to a plain Bash, especially on older machines. In most cases this is negligible, but in constrained environments speed could be a factor.  
- **Different Subprocess Handling:** Fish’s execution model (no subshell forks for certain operations) can be a limitation in cases where isolating commands is desired. For instance, in Bash you might intentionally run a command in a subshell to avoid affecting the parent environment; in fish, achieving similar isolation might require workarounds.  
- **Limited Adoption in System Scripts:** Virtually no operating system uses fish as the default shell for system scripts or user login by default. This means knowledge of fish is mostly useful for an individual’s development/workstation environment. In collaborative or production environments, one often still needs to know Bash for writing deployable scripts, since assuming fish is present would be unsafe.

* Zsh
** Origins  
The **Z shell (Zsh)** was created by Paul Falstad in 1990 while he was a university student ([Z shell - Wikipedia](https://en.wikipedia.org/wiki/Z_shell#:~:text=Zsh%20was%20created%20by%20Paul,handling%2C%20and%20themeable%20%2090)). The name “zsh” comes from a Yale professor’s login id (“zsh”), which Falstad adopted as a convenient name ([Z shell - Wikipedia](https://en.wikipedia.org/wiki/Z_shell#:~:text=Paul%20Falstad%20wrote%20the%20first,8)). Zsh was designed as an extended Bourne shell that merges features from the Korn shell (ksh) and C shell (csh/tcsh) families ([Z shell - Wikipedia](https://en.wikipedia.org/wiki/Z_shell#:~:text=The%20Z%20shell%20,85%2C%20and%20tcsh)). It was released under the MIT License and has since been maintained and improved by an active development team (including notable contributors like Peter Stephenson). Over the years, Zsh has become known for its rich feature set and flexibility.

** Uses  
Zsh can serve as both an interactive login shell and a scripting shell, though it’s most celebrated as an interactive shell for power users ([Z shell - Wikipedia](https://en.wikipedia.org/wiki/Z_shell#:~:text=The%20Z%20shell%20,85%2C%20and%20tcsh)). Many developers switch to Zsh for daily terminal work because of its customization options and community frameworks (for example, *Oh My Zsh*). Zsh is the default shell on macOS since 2019 (Catalina), replacing Bash ([Z shell - Wikipedia](https://en.wikipedia.org/wiki/Z_shell#:~:text=Zsh%20is%20available%20for%20Microsoft,large%20and%20active%20contributor%20base)). It’s also the default on Kali Linux and available on virtually all Linux/BSD systems via package managers. In real-world use, Zsh often appears in scenarios where users want a highly tailored command-line experience: custom prompts with git status, plugins for Kubernetes or AWS, and so on. Scripting with Zsh is less common in distributed scripts (since Bash or sh is safer for portability), but Zsh can certainly be used for writing personal or system scripts as long as the target environment has it installed.

** Advantages  
- **Feature Superset:** Zsh includes almost all features of Bash and then some. For example, it has powerful **glob patterns** (Zsh’s filename matching can do recursive `**` globs, regex-like qualifiers, etc. without extra commands) ([Z shell - Wikipedia](https://en.wikipedia.org/wiki/Z_shell#:~:text=Zsh%20was%20created%20by%20Paul,handling%2C%20and%20themeable%20%2090)). It also improves on array handling (allowing easier slicing and manipulation) and adds floating-point math support. Essentially, anything you can script in Bash can be done in Zsh, often with cleaner or more flexible syntax.  
- **Programmable Completions and Corrections:** Zsh has a powerful built-in completion system that is highly customizable. Even without third-party additions, Zsh can tab-complete options for most commands and even complete file arguments in context (like hostnames for ssh, branch names for git, etc.). It also has a spelling correction feature – if you mistype a command, Zsh can suggest or automatically correct it (e.g., typing “gti status” could be corrected to “git status”).  
- **Customization and Theming:** One of Zsh’s strong points is how easy it is to customize the prompt and behavior. Users can create elaborate prompts with colors, git status, time, etc., using Zsh’s prompt expansion facilities. The community-driven **Oh My Zsh** framework (and similar ones like Prezto) provide hundreds of ready-made plugins and themes, making it simple to add features (such as syntax highlighting, autosuggestions, or alias collections for common tasks) to Zsh. This ecosystem makes Zsh extremely adaptable to personal workflows.  
- **Interactive Conveniences:** Zsh offers conveniences such as **autosuggestions** (with a plugin, similar to fish), better **history search** (you can search through history with substring matches, share history across sessions, etc.), and **global aliases** (for example, you can alias `..="cd .."` to navigate directories faster, even as part of longer commands). Many of these features can be enabled via configuration or plugins, allowing a more efficient command-line use.  
- **Good Bash Compatibility:** Despite its extra features, Zsh is largely compatible with Bash scripts. Most well-written Bash scripts can run in Zsh without changes (especially if they avoid Bash-only extensions). Zsh can execute in a POSIX compatibility mode if invoked as `sh` or via `emulate sh`. This means one can often use Zsh as a drop-in interactive shell without sacrificing the ability to run standard Bash/sh scripts ([Z shell | Apple Wiki | Fandom](https://apple.fandom.com/wiki/Z_shell#:~:text=Z%20shell%20is%20similar%20to%2C,1)).

** Disadvantages  
- **Complexity:** With the vast number of features and options, Zsh can be overwhelming to fully learn. The manual is extensive, and mastering all the nuances (completion system, zstyle configurations, etc.) requires time. New users might only scratch the surface of Zsh’s capabilities, and troubleshooting custom configurations can be complex.  
- **Inconsistent Default Configurations:** Unlike fish, which is designed to be friendly out of the box, Zsh can be rather plain by default. It relies on the user (or frameworks like Oh My Zsh) to enable many of the niceties. For instance, Zsh doesn’t automatically have syntax highlighting or autosuggestion – you need additional setup for those. This means that the quality of the interactive experience depends on how well the user configures their `~/.zshrc`.  
- **Minor Incompatibilities:** While Zsh aims for Bash compatibility, there are subtle differences. Some Bash scripts that use corner-case behavior might not work identically in Zsh. For example, Zsh has slightly different rules for `$PATH` hashing (how it remembers command locations), and some Bash-specific extensions (like the `<<-EOF` minus-indented heredoc or certain `shopt` options) don’t have direct equivalents or need different handling. These are edge cases, but in a large environment it might cause issues if someone unknowingly runs a Bash script under Zsh. According to documentation, Zsh is “similar to, but not completely compatible with, KornShell,” and by extension there are slight Bash differences ([Z shell | Apple Wiki | Fandom](https://apple.fandom.com/wiki/Z_shell#:~:text=Z%20shell%20is%20similar%20to%2C,1)).  
- **Resource Usage:** Zsh can be slightly heavier than Bash in terms of memory, especially when lots of plugins are enabled. In most modern scenarios this is negligible, but in constrained systems or when launching many shell instances, the additional overhead of Zsh’s feature set (loading completions, etc.) might be a minor disadvantage.  
- **Availability in Some Systems:** While common on developer machines, Zsh might not be present on very minimal systems or certain Unix environments unless installed. For example, a default Docker container or a stripped-down server might include `/bin/sh` and maybe Bash, but not Zsh. This means one can’t rely on Zsh being available everywhere without an installation step.

** Capabilities  
Zsh’s capabilities span the full range of shell functionality and beyond. It supports all POSIX shell features and adds others from Korn shell (like associative arrays, floating-point arithmetic, and more powerful `[[ ... ]]` conditional expressions). Its **extended globbing** lets users match filenames with complex criteria (e.g., `**/*.c` to recurse directories, or `*(.)` to match regular files vs `*(@)` for symlinks, etc.). Zsh also has a concept of **named directories** – you can assign a shortcut name to a directory (with `hash -d`) and then refer to it as `~name` in paths ([Z shell - Wikipedia](https://en.wikipedia.org/wiki/Z_shell#:~:text=Zsh%20was%20created%20by%20Paul,handling%2C%20and%20themeable%20%2090)). The shell’s completion system (accessible via the `compdef` and `zstyle` mechanisms) is programmable in great detail, allowing context-sensitive completions. Zsh supports **autoloadable functions**, where functions can be loaded on demand from files (this is used in how its completion scripts work). For interactive usage, it offers line editing through Zle (Zsh Line Editor), which is highly configurable. Zsh can do advanced prompt theming with built-in escapes for git status, time, exit codes of the last command, etc. Another notable capability is process substitution (like Bash) and **zsh-specific redirection operators** (for example, `>&|` to force overwrite on redirection, and `>|` to override the `noclobber` setting). Zsh even allows **inline glob qualifiers** to filter file lists (e.g., `ls **/*.log(.m0)` would list only empty regular *.log files, where `(.m0)` means regular file of size 0). In summary, Zsh is one of the most powerful shells, suitable for interactive use, scripting, and as a framework for customizing one’s shell environment.

+BEGIN_SRC shell  
# Zsh example: extended globbing and named directories  
echo **/*.log(D)    # list all *.log files recursively, including dotfiles (D)  
hash -d proj=~/projects  
cd ~proj            # quickly change directory using the named dir 'proj'  
+END_SRC

In this snippet, `**/*.log(D)` uses Zsh’s globbing to find all `.log` files in the current directory and subdirectories; the `(D)` glob qualifier includes dotfiles in the results (a Zsh extension). The `hash -d` command creates an alias for a directory (`proj` for `~/projects`), and `cd ~proj` demonstrates using that named directory. These features go beyond what standard Bash offers by default (Bash would require enabling `globstar` for `**`, and has no direct equivalent of named directories).

** Limitations  
- **Not Default Everywhere:** Unlike Bash, Zsh isn’t universally present on all systems (though it’s increasingly common). Scripts or tools that require Zsh will need an environment where Zsh is installed. This is usually not an issue on modern developer machines, but it can be on containers or restricted systems.  
- **Learning and Configuration Overhead:** To get the most out of Zsh, one often relies on external frameworks (Oh My Zsh, Prezto, etc.) and numerous configuration tweaks. This means there’s a maintenance aspect – updating plugins, ensuring compatibility after updates, etc. In contrast, Bash, while less feature-rich, often requires fewer moving parts (since many systems come pre-configured with a basic usable Bash setup).  
- **Shell Specific Idiosyncrasies:** Some behaviors in Zsh are unique. For instance, by default Zsh doesn’t split words on unquoted parameters the same way Bash does (`$=` and `${=VAR}` are used for word-splitting in Zsh). These differences are usually only encountered in scripting, but they can surprise users expecting Bash-like behavior. Thus, when writing cross-shell scripts or functions, these nuances must be kept in mind.  
- **Tooling Expectation:** Some command-line tools and tutorials assume Bash by default. For example, they might provide Bash-specific setup instructions (`source <(tool completion)`). Using Zsh with such tools might require translating those instructions or enabling Bash emulation. Over time, most tools have added Zsh support, but occasionally a new or niche tool may not have Zsh instructions readily available.

* Eshell
** Origins  
**Eshell** (Emacs Shell) is a shell implemented entirely in Emacs Lisp, created by John Wiegley around 1998 ([Presenting the EShell](https://howardism.org/Technical/Emacs/eshell-presentation.html#:~:text=John%20Wiegley%20created%20EShell%20in,1998)). It was developed to provide a Unix-like shell within Emacs, particularly to offer a consistent shell environment on operating systems like Windows where the standard Unix shells might be lacking. Eshell became an official part of GNU Emacs starting with Emacs 21, and it has been maintained as a built-in feature since then. Its design goals included being as portable as Emacs itself (working wherever Emacs runs) and integrating tightly with Emacs’s capabilities.

** Uses  
Eshell is used from *inside Emacs* as an alternative to the external shell (like Bash or Zsh). Developers who spend most of their time in Emacs can use Eshell to run shell commands without leaving the editor. It’s especially useful in scenarios where one wants to combine shell tasks with Emacs capabilities: for example, navigating remote servers via Tramp (Emacs’s remote file access) and running commands there, or capturing command output in Emacs buffers for further editing. Because Eshell is an Emacs mode, users can open multiple Eshell buffers, copy and paste results easily, and even embed Eshell in Emacs windows alongside code editors. Real-world uses include: quick file operations (using `ls`, `cp`, etc.) inside Emacs, manipulating output with Emacs Lisp on the fly, and seamlessly switching between shell and editor in a single interface. However, Eshell is not typically used for writing standalone scripts (you wouldn’t use Eshell to write a system script; instead, it’s an interactive tool).

** Advantages  
- **Deep Emacs Integration:** The primary advantage of Eshell is that it’s part of Emacs, meaning it has direct access to Emacs internals. Users can invoke Emacs Lisp functions directly in the shell. For example, one can call `(message "Hi")` or use Emacs commands like `find-file` as if they were shell commands. This allows combining shell commands and Lisp seamlessly, which is extremely powerful for certain workflows (you can process output with Lisp, open results in Emacs buffers, etc.).  
- **Cross-Platform Consistency:** Since Eshell is written in Lisp and does not rely on external binaries for its core functionality, it behaves the same on all platforms ([Mastering Eshell - Mastering Emacs ](https://www.masteringemacs.org/article/complete-guide-mastering-eshell#:~:text=Eshell%20is%20a%20shell%20written,environment%20Emacs%20itself%20runs%20on)). Common Unix commands (`ls`, `mv`, `grep`, etc.) are built into Eshell (implemented in Lisp), so even on Windows you get a Unix-like shell experience without needing all those utilities installed ([Mastering Eshell - Mastering Emacs ](https://www.masteringemacs.org/article/complete-guide-mastering-eshell#:~:text=Eshell%20is%20a%20shell%20written,environment%20Emacs%20itself%20runs%20on)). This makes Eshell a handy environment on systems that lack typical Unix command-line tools.  
- **Extensibility:** Eshell can be extended by writing Emacs Lisp. Users can add their own commands or override existing ones. For instance, if you want a special behavior for `ls` or a new command `mygrep`, you can define it in Emacs Lisp. Because it’s part of Emacs, you can also leverage Emacs packages – for example, use Emacs’s autocomplete for command names or history search via standard Emacs mechanisms.  
- **Unified Environment:** With Eshell, the distinction between “shell” and “editor” blurs. You can stay in one Emacs window to do almost everything: run version control commands (Eshell has built-in `git` command integration), launch builds, and edit files. This can streamline workflows since you’re not context-switching between terminal and editor. Also, the shell buffer is just an Emacs buffer, so you can scroll, search, and copy text in it like any text file.  
- **Remote and Multi-session Capabilities:** Eshell works with Emacs’s Tramp, so you can `cd` into remote directories (e.g., `/ssh:you@server:`) and have shell interactions directly over SSH inside Emacs ([Mastering Eshell - Mastering Emacs ](https://www.masteringemacs.org/article/complete-guide-mastering-eshell#:~:text=Native%20Tramp%20Support)). You can also have multiple Eshell sessions (buffers) for different tasks. Each Eshell buffer is independent, which can be useful (for example, one could be `root` on a remote server, another a local user shell).

** Disadvantages  
- **Emacs-Only:** Eshell only runs inside Emacs; it’s not an external shell you can invoke in a terminal or use for system scripts. This ties its usage to the Emacs environment. If Emacs is not running or available, you can’t use Eshell. This dependency means Eshell isn’t a general replacement for Bash/Zsh in contexts like logging into a server or writing a `#!/bin/sh` script.  
- **Performance Constraints:** Being implemented in Emacs Lisp, Eshell can be slower than native shells for certain operations. While running external commands is usually fine (those just spawn processes like any shell), the Lisp-based built-in commands (like the Lisp version of `ls`) might be slower on very large directories compared to the system’s optimized `ls`. Moreover, heavy processing in Eshell (especially involving Lisp loops or handling huge outputs in an Emacs buffer) can be less efficient than doing the same in a native shell or external program.  
- **Incompleteness and Quirks:** Eshell tries to emulate a POSIX shell, but not everything is covered. Some shell features or utilities might be missing or not fully compatible with their Unix counterparts. For example, complex shell expansions or redirection semantics may not work exactly as in Bash. There is also a learning curve to understand what’s an Eshell built-in command versus when it dispatches to an external command. Users might encounter surprising behavior (for instance, typing `ls` uses the Emacs Lisp implementation, but typing `/bin/ls` would use the external one). Debugging such issues requires Emacs Lisp knowledge.  
- **Not Suitable for All Interactive Programs:** Eshell is not a terminal emulator, so programs that expect full control of the terminal (interactive text UIs using curses, or programs like `top`, `nano`, etc.) will not display correctly in Eshell ([Eshell: The Emacs Shell](https://www.gnu.org/software/emacs/manual/html_mono/eshell.html#:~:text=If%20you%20try%20to%20run,programs%20in%20Emacs%E2%80%99s%20terminal%20emulator)). Eshell mitigates this by detecting “visual” commands and automatically opening an Emacs terminal emulator for them ([Eshell: The Emacs Shell](https://www.gnu.org/software/emacs/manual/html_mono/eshell.html#:~:text=If%20you%20try%20to%20run,programs%20in%20Emacs%E2%80%99s%20terminal%20emulator)), but this means a context switch to a different buffer/mode. This limitation makes Eshell less convenient if your workflow involves a lot of interactive console programs.  
- **Different Shell Language:** While Eshell’s commands superficially resemble shell commands, the scripting syntax is actually different (being influenced by Lisp). For example, Eshell does support `if/else` and `for` loops, but their usage can differ from Bash, and one can also mix Lisp forms in these. This hybrid nature can be confusing. It’s neither pure Bash syntax nor pure Lisp, but a blend, which can trip up users expecting one or the other.

** Capabilities  
Eshell’s capabilities combine shell features with Emacs Lisp power. It can run external commands just like any shell, and also has many built-in replacements written in Lisp (for portability). For instance, when you run `ls` or `grep` in Eshell, you are often invoking Emacs Lisp functions that output in the shell buffer. Eshell supports piping (`|`) and redirection (`>`, `>>`) similar to other shells, and you can pipe output not only into other commands but also into elisp functions. One unique feature is that you can capture the output of a command directly into an Emacs buffer or a variable. Since it’s inside Emacs, the results of commands are accessible for further editing or manipulation. Eshell also allows Lisp evaluation inline: any expression in between `$( )` or within `[...]` (or a standalone `(<elisp>)`) can be evaluated as Emacs Lisp, returning either text to the shell or Lisp objects that can be passed between commands. It supports globbing and filename expansion (including remote file names via Tramp). For navigation, Eshell understands the usual shell commands (`cd`, `pushd`, `popd`) and ties into Emacs bookmarks and directory history. A powerful aspect is that Eshell can leverage Emacs’s autocompletion (via `pcomplete`) to offer intelligent completion for both command names and their arguments. In summary, Eshell’s capabilities are not about introducing new shell primitives, but about integrating Emacs’s strengths (Lisp, buffers, cross-platform support) with shell usage.

+BEGIN_SRC shell  
# Eshell example: mixing shell commands and Emacs Lisp  
echo "Home directory: $HOME"      # shell variable usage in Eshell (prints HOME)  
(message "Hello from Emacs Lisp") # call an Emacs Lisp function from the shell  
find-file ~/notes/todo.org        # invoke an Emacs command (open a file in Emacs)  
+END_SRC

In this example, the first line behaves like a normal shell command (printing an environment variable). The second line is in parentheses, which causes Eshell to evaluate it as an Emacs Lisp expression – here it calls the Lisp function `message`. The third line uses an Emacs command `find-file` as if it were a shell command; Eshell recognizes it and opens the file in an Emacs buffer. These capabilities show how Eshell blurs the line between shell and editor, allowing direct use of Emacs features in the shell.

** Limitations  
- **Not a System Shell:** Eshell cannot replace `/bin/sh` or be used as a login shell for the system. It’s only available when Emacs is running. This means it’s not usable for things like SSHing directly (you wouldn’t `ssh user@host -t eshell` effectively) or writing cron jobs. It’s strictly an interactive shell inside an editor.  
- **Steep Learning for Complex Use:** Using Eshell for basic commands is straightforward, but tapping into its full power (like capturing Lisp return values in pipelines, or writing Eshell-specific functions) requires knowledge of Emacs Lisp and the Eshell manual. This is a niche skill set. Most users use Eshell for simple things and drop to a regular terminal for more complex interactions.  
- **Buffer Output vs Terminal Output:** Because Eshell outputs to an Emacs buffer, very long outputs or continuous outputs (like tailing a file) can be harder to manage and might slow down Emacs. A traditional terminal might handle streaming output more gracefully. In Eshell, one might need to trim buffers or be cautious to avoid flooding the interface with too much text at once.  
- **Concurrent Process Handling:** While you can run asynchronous processes in Eshell (it can run a process in the background), managing them isn’t as straightforward as in a normal terminal. Job control (suspending with Ctrl-Z, etc.) is not the same in Eshell as in Bash. You might end up using Emacs commands to manage processes. This can be seen as a limitation if you try to use Eshell exactly like a terminal shell – it has its own conventions for process management.


* Footnotes

[fn:1] as of 07/03/25
