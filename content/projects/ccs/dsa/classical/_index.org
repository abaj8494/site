+++
title = "Classical Algorithms"
categories = ["computer-science", "notes"]
tags = ["bit-manipulation", "2-pointer", "prefix-sum", "backtracking", "greedy", "memoisation"]
layout = "custom-list"
mathjax = "true"
tikzajax = "true"
+++


{{< collapse id="classical-algorithms" folded="false" >}}


#+BEGIN_QUOTE
Try to not to use Machine Learning
---Rule #1 in [[https://developers.google.com/machine-learning/guides/rules-of-ml][Google's Machine Learning Handbook]]
#+END_QUOTE

if the problem can be solved in an analysed time and space complexity we should do it classically. Machine Learning requires *data*.

| algorithm      | time-complexity             | function                                          | style     |
|----------------+-----------------------------+---------------------------------------------------+-----------|
| BFS            | $\mathcal{O}(V+E)$          | Shortest Path                                     | Traversal |
| DFS            | $\mathcal{O}(V+E)$          | Topo-sorting, Cycle testing, connected components | Traversal |
| Kruskal        | $\mathcal{O}(E\log(V))$     | MST                                               | Greedy    |
| Prim           | $\mathcal{O}((E+V)\log(V))}$ | MST                                               | Greedy    |
| Dijkstra       | $\mathcal{O}((E+V)\log(V))}$ | Shortest Path, non-unit weights                   | Greedy    |
| Bellman-Ford   | $\mathcal{O}(VE)$           | Negative Weight SP                                | DP        |
| Floyd-Warshall | $\mathcal{O}(V^3)$          | All Pairs SP.                                     | DP        |
| Ford-Fulkerson | $\mathcal{O}(Ef)$           | Max flow / min-cut with untethered implementation | Greedy    |
| Edmond-Karp    | $\mathcal{O}(VE^2)$         | Max flow with BFS.                                | Greedy    |

testing mathjax: $\abs{5}$ (mathtools)

** 2 Pointers
:PROPERTIES:
:CUSTOM_ID: two-pointers
:END:

*** schematic

#+BEGIN_CENTER
#+CAPTION: fast and slow pointers
[[{{< cwd >}}/2pointers.gif]]
#+END_CENTER

this paradigm works well on [[/projects/ccs/dsa/structures#arrays][arrays]], reducing the time complexity of some popular problems from $\mathcal{O}(n^2)$ to $\mathcal{O}(n)$.

there are a few flavours of this technique: fast and slow; opposite pointers, but ultimately we do keep track of two indices =left= and =right=. sometimes abbreviated to =l= and =r= in the code.

common problems that this algorithm works well on include:
- finding cycles in a linked list (fast and slow pointers)
- finding pairs
- comparing elements from opposite ends of a data structure

** Sliding Window
:PROPERTIES:
:CUSTOM_ID: sliding-window
:END:


this is a special case of the two-pointers strategy [[#two-pointers][above]], and maintains a fixed-window length across the *array*.

it can be used to solve problems of the sort:
- maximise length of substring
- maintain sum within a target value
- [[/projects/ccs/dsa/leetcode/solutions#p3][leetcode problem 3]]

it is often combined with [[/projects/ccs/dsa/structures#hashmaps][hashmaps]] to keep track of the elements within the window

** Binary Search
:PROPERTIES:
:CUSTOM_ID: binary-search
:END:

this is technically an expansion of the [[#two-pointers][two pointers]] pattern.

it can be used on any list that has a monotonic function.

privvy to utilise any condition for sorting; e.g. T/F

#+BEGIN_SRC python
  def binary_search(arr: List[int], target: int) -> int:
      left, right = 0, len(arr) - 1
      first_true_index = -1
      while left <= right:
	  mid = (left + right) // 2
	  if feasible(mid):
	      first_true_index = mid
	      right = mid -1
	  else:
	      left = mid+1
      return first_true_index
#+END_SRC

we can apply the above prototype to [[/projects/ccs/dsa/leetcode/solutions#p153][leetcode problem 153]]

** Breadth First Search
:PROPERTIES:
:CUSTOM_ID: bfs
:END:

this algorithm is good for finding the *shortest path* between two nodes.

it is worth realising that /a tree is just a graph without cycles/.

BFS uses a [[/projects/ccs/dsa/structures#queue][queue]] data-structure. we can implement bfs by using a queue which is built with a deque:

#+BEGIN_SRC python
  from collections import deque

  def bfs_by_queue(root):
      queue = deque([root])
      while len(queue) > 0:
	  node = queue.popleft()
	  for child in node.children:
	      if OK(child):
		  return FOUND(child)
	      queue.append(child)
      return NOT_FOUND
#+END_SRC

see [[/projects/ccs/dsa/leetcode/solutions#p102][leetcode problem 102]]


** Backtracking
:PROPERTIES:
:CUSTOM_ID: backtracking
:END:

this is just an extension of DFS (?), with the caveat that there is no longer a pre-built structure (i.e. an underlying tree)

see [[/projects/ccs/dsa/leetcode/solutions#p17][leetcode problem 17]]


** Dynamic Programming
:PROPERTIES:
:CUSTOM_ID: dp
:END:

this is one of the more difficult patterns (allegedly). there are two types:

*** top-down

back-tracking + memoisation

*** bottom-up

solve smallest subproblems first.

fill out a table


** Depth First Search
:PROPERTIES:
:CUSTOM_ID: dfs
:END:

this algorithm is better for finding a route to a vertex that is deep within the search-tree.

we use an implementation of a "stack" to execute this algorithm, but in practice we can often use recursion paired with a "call-stack"!

DFS is good for:
- exploring all paths
- detecting cycles
- memory efficient searchs
- deep searching

see [[/projects/ccs/dsa/leetcode/solutions#p200][leetcode problem 200]]


** Heap / Priority Queue
:PROPERTIES:
:CUSTOM_ID: heaps
:END:

heaps are implementations of priority queues (?)

this data structure is used to solve problems of the type: "top K" and is slightly unintuitive, because to find the top K "largest", we require a min-heap, and to find the top K "smallest", we require a max-heap:

#+BEGIN_CENTER
#+HTML: <div style="display: flex; align-items: center; justify-content: center; gap: 20px;">
#+HTML:   <div style="text-align: center; display: flex; flex-direction: column; align-items: center;">
#+CAPTION: min-heap, k-largest
#+ATTR_HTML: :width 350px :class lateximage
{{< tikztwo >}}
\usetikzlibrary{arrows,positioning, calc}
\tikzstyle{vertex}=[draw,fill=black!15,circle,minimum size=20pt,inner sep=0pt]

\begin{document}
\begin{tikzpicture}[scale=1.5,transform shape,very thick,level/.style={sibling distance=30mm/#1}]
\node [vertex] (r){$8$}
  child {
    node [vertex] (a) {$7$}
    child {
      node [vertex] {$9$}
    }
    child {
      node [vertex] {$13$}
    }
  }
  child {
    node [vertex] {$4$}
    child {
      node [vertex] {$5$}
    }
    child {
      node [vertex] {$76$}
    }
  };
\end{tikzpicture}
\end{document}
{{< /tikztwo >}}
#+HTML:   </div>
#+HTML:   <div style="text-align: center; display: flex; flex-direction: column; align-items: center;">
#+CAPTION: max-heap, k-smallest
#+ATTR_HTML: :width 350px :class lateximage
{{< tikztwo >}}
\usetikzlibrary{arrows,positioning, calc}
\tikzstyle{vertex}=[draw,fill=black!15,circle,minimum size=20pt,inner sep=0pt]

\begin{document}
\begin{tikzpicture}[scale=1.5,transform shape,very thick,level/.style={sibling distance=30mm/#1}]
\node [vertex] (r){$20$}
  child {
    node [vertex] (a) {$15$}
    child {
      node [vertex] {$9$}
    }
    child {
      node [vertex] {$8$}
    }
  }
  child {
    node [vertex] {$6$}
    child {
      node [vertex] {$4$}
    }
    child {
      node [vertex] {$2$}
    }
  };
\end{tikzpicture}
\end{document}
{{< /tikztwo >}}

#+HTML:   </div>
#+HTML:   </div>
#+END_CENTER

see leetcode problems:
- [[/projects/ccs/dsa/leetcode/solutions#p45][45]]
- [[/projects/ccs/dsa/leetcode/solutions#p347][347]]
- [[/projects/ccs/dsa/leetcode/solutions#p973][973]]


** Divide and Conquer
:PROPERTIES:
:CUSTOM_ID: divide-conquer
:END:


** Trie
:PROPERTIES:
:CUSTOM_ID: trie
:END:


this refers to the *data-structure*, but algorithms for *insertion*, *deletion* and *search* can be documented here.

there is also a relation with a /Radix Tree/ which is a compressed version of a trie, but I'm not sure how it all connects.

** Union Find
:PROPERTIES:
:CUSTOM_ID: union-find
:END:


again, I am not sure where to draw the line between *data-structure* and *algorithm* here.

it seems that this is a data-structure for handling a collection of "disjoint-sets" and efficiently performs two primary operations:
- union: merging two sets and;
- find: determining which set an element belongs to

** Greedy
:PROPERTIES:
:CUSTOM_ID: greedy
:END:



** Graph
:PROPERTIES:
:CUSTOM_ID: graph
:END:

we have already covered a couple of "graph" algorithms on this page: [[/projects/ccs/dsa/classical#binary-search][binary search]], [[/projects/ccs/dsa/classical#bfs][breadth first search]],  [[/projects/ccs/dsa/classical#dfs][depth first search]]. but there are many more such algorithms:
- prim
- kruskal
- dijkstra
  #+BEGIN_CENTER
  #+CAPTION: dijkstra fail
    {{< tikztwo >}}
\usetikzlibrary{arrows,positioning, calc}
\tikzset{
    %Define standard arrow tip
    ->,>=stealth',shorten >=1pt,auto,node distance=3cm, very thick,
    % Define arrow style
    main node/.style={
        circle,
        fill=blue!20,
        draw,
        font=\sffamily\Large\bfseries
    }
}

\begin{document}
\begin{tikzpicture}[,]

  \node[main node] (A) {A};
  \node[main node] (C) [below of=A] {C};
  \node[main node] (B) [right of=A] {B};
  \node[main node] (D) [right of=C] {D};

  \path[every node/.style={font=\sffamily\small}]
    (A) edge node {4} (C)
        edge node {3} (B)
    (C) edge node {-2} (B)
    (B) edge node {1} (D);
\end{tikzpicture}
\end{document}
{{< /tikztwo >}}
#+END_CENTER


#+BEGIN_CENTER
#+CAPTION: bellman ford algorithm
[[{{< cwd >}}/bellman-ford.gif]]
#+END_CENTER


** Linear Programming

a "sledgehammer" of the trade according to [[/tags/authors/dasgupta][Dasgupta]]

** Recursion

recursion is probably a concept that deserves at least a small amount of recognition as a concept, and designated place wherein which to place notes.

this algorithmic technique goes hand-in-hand with [[/projects/ccs/dsa/structures#trees][trees]] and [[/projects/ccs/dsa/classical#divide-conquer][divide and conquer]]

** Searching

searching is one of the main concerns of [[#graph][graph algorithms]]: finding a route to a particular vertex or finding the value of a vertex itself.

we have covered [[/projects/ccs/dsa/classical#binary-search][binary search]], [[/projects/ccs/dsa/classical#bfs][breadth first search]] and [[/projects/ccs/dsa/classical#dfs][depth first search]], but we have not yet made notes about:
- heuristic searches
- a* star search
- monte carlo

** Sorting

we have not covered sorting at all on this page, it seems to be one of the less examined topics in [[/projects/ccs/dsa/leetcode][leetcode]]. nonetheless, it is an important and interesting application of the data structures and algorithms we know.

*** time complexities[fn:1]


#+begin_export html
<style>
  /* Layout: let content decide widths */
  table.alg-table { width: 100%; border-collapse: collapse; table-layout: auto; }
  .alg-table th, .alg-table td { border: 1px solid var(--table-border, #ddd); padding: .5rem .6rem; vertical-align: middle; }
  .alg-table thead th { background: var(--table-head-bg, #f7f7f7); position: relative; }
  .alg-table th[colspan] { text-align: center; }
  .alg-table th[rowspan] { text-align: left; }
  /* Prevent formula wrapping but let algorithm names wrap if needed */
  .alg-table td:not(.alg-name) { white-space: nowrap; }
  .alg-table td.alg-name { white-space: normal; }

  /* Sort UI: small dropdown aligned right (optional) */
  .sort-select { position: absolute; right: .4rem; top: .3rem; font-size: .8rem; }

  /* Click-to-sort affordance (works even without dropdowns) */
  .sort-click { cursor: pointer; }
  .sort-click::after { content: " ⇅"; opacity: .5; font-size: .9em; }

  /* Resizer handle on each header */
  .col-resizer {
    position: absolute; right: 0; top: 0; width: 6px; height: 100%;
    cursor: col-resize; user-select: none;
  }
  .col-resizer:hover { background: rgba(0,0,0,.08); }
</style>

<table class="alg-table" id="alg-table">
  <colgroup>
    <col style="width: 18%"><!-- Algorithm -->
    <col span="3"><!-- Time (auto widths) -->
    <col style="width: 14%"><!-- Space -->
  </colgroup>
  <thead>
    <tr>
      <th rowspan="2" class="sort-click" data-col="0" data-type="alpha">Algorithm
        <span class="col-resizer" data-col="0"></span>
      </th>
      <th colspan="3">Time</th>
      <th rowspan="2" class="sort-click" data-col="4" data-type="alpha">Space (worst)
        <select class="sort-select" data-col="4" data-type="alpha">
          <option value="">—</option><option value="asc">↑</option><option value="desc">↓</option>
        </select>
        <span class="col-resizer" data-col="4"></span>
      </th>
    </tr>
    <tr>
      <th class="sort-click" data-col="1" data-type="alpha">Best <span class="col-resizer" data-col="1"></span></th>
      <th class="sort-click" data-col="2" data-type="alpha">Average <span class="col-resizer" data-col="2"></span></th>
      <th class="sort-click" data-col="3" data-type="alpha">Worst <span class="col-resizer" data-col="3"></span></th>
    </tr>
  </thead>
  <tbody>
    <tr><td class="alg-name">quicksort</td><td>$\Omega(n\log n)$</td><td>$\Theta(n\log n)$</td><td>$\mathcal{O}(n^2)$</td><td>$\mathcal{O}(\log n)$</td></tr>
    <tr><td class="alg-name">mergesort</td><td>$\Omega(n\log n)$</td><td>$\Theta(n\log n)$</td><td>$\mathcal{O}(n\log n)$</td><td>$\mathcal{O}(n)$</td></tr>
    <tr><td class="alg-name">timsort</td><td>$\Omega(n)$</td><td>$\Theta(n\log n)$</td><td>$\mathcal{O}(n\log n)$</td><td>$\mathcal{O}(n)$</td></tr>
    <tr><td class="alg-name">heap</td><td>$\Omega(n\log n)$</td><td>$\Theta(n\log n)$</td><td>$\mathcal{O}(n\log n)$</td><td>$\mathcal{O}(1)$</td></tr>
    <tr><td class="alg-name">bubble</td><td>$\Omega(n)$</td><td>$\Theta(n^2)$</td><td>$\mathcal{O}(n^2)$</td><td>$\mathcal{O}(1)$</td></tr>
    <tr><td class="alg-name">insertion</td><td>$\Omega(n)$</td><td>$\Theta(n^2)$</td><td>$\mathcal{O}(n\log n)$</td><td>$\mathcal{O}(1)$</td></tr>
    <tr><td class="alg-name">selection</td><td>$\Omega(n^2)$</td><td>$\Theta(n^2)$</td><td>$\mathcal{O}(n^2)$</td><td>$\mathcal{O}(1)$</td></tr>
    <tr><td class="alg-name">bucket</td><td>$\Omega(n+k)$</td><td>$\Theta(n+k)$</td><td>$\mathcal{O}(n^2)$</td><td>$\mathcal{O}(n)$</td></tr>
    <tr><td class="alg-name">radix</td><td>$\Omega(nk)$</td><td>$\Theta(nk)$</td><td>$\mathcal{O}(nk)$</td><td>$\mathcal{O}(n+k)$</td></tr>
  </tbody>
</table>

<script>
(function () {
  const table = document.getElementById('alg-table');
  const tbody = table.tBodies[0];

  // --- Sorting helpers ---
  const latexToKey = s => (s || "").replace(/\\[a-zA-Z]+/g,'')
    .replace(/[{}$]/g,'').replace(/\\/g,'').replace(/\s+/g,' ').trim().toLowerCase();

  function sortBy(col, dir, type='alpha') {
    const rows = Array.from(tbody.rows);
    const mul = dir === 'desc' ? -1 : 1;
    rows.sort((r1, r2) => {
      let a = r1.cells[col]?.innerText || "";
      let b = r2.cells[col]?.innerText || "";
      if (type === 'num') {
        const na = parseFloat(a.replace(/[^\d.\-eE]/g,'')) || 0;
        const nb = parseFloat(b.replace(/[^\d.\-eE]/g,'')) || 0;
        return (na - nb) * mul;
      } else {
        a = latexToKey(a); b = latexToKey(b);
        return a < b ? -1*mul : a > b ? 1*mul : 0;
      }
    });
    rows.forEach(r => tbody.appendChild(r));
  }

  // Click-to-sort (toggle asc/desc)
  const state = {}; // col -> 'asc' | 'desc'
  table.querySelectorAll('.sort-click').forEach(th => {
    th.addEventListener('click', () => {
      const col = +th.dataset.col;
      const type = th.dataset.type || 'alpha';
      const next = state[col] === 'asc' ? 'desc' : 'asc';
      state[col] = next;
      sortBy(col, next, type);
    });
  });

  // Dropdown sort (optional UI)
  table.querySelectorAll('.sort-select').forEach(sel => {
    sel.addEventListener('change', e => {
      const col = +sel.dataset.col;
      const type = sel.dataset.type || 'alpha';
      if (!sel.value) return;
      sortBy(col, sel.value, type);
    });
  });

  // --- Column resizing (drag handles on THs) ---
  const colgroup = table.querySelector('colgroup');
  if (colgroup) {
    const cols = colgroup.querySelectorAll('col');
    let active = null, startX = 0, startW = 0;

    function onMove(e) {
      if (!active) return;
      const dx = e.clientX - startX;
      const newW = Math.max(60, startW + dx);
      cols[active].style.width = newW + 'px';
    }
    function onUp() { active = null; document.removeEventListener('mousemove', onMove); }

    table.querySelectorAll('.col-resizer').forEach(handle => {
      handle.addEventListener('mousedown', e => {
        const colIdx = +handle.dataset.col;
        // Ensure a <col> exists for this index
        if (!cols[colIdx]) return;
        active = colIdx;
        startX = e.clientX;
        // compute current pixel width
        const cell = table.tHead.querySelectorAll('tr:last-child th')[colIdx] || table.tHead.querySelectorAll('th')[colIdx];
        startW = (cols[colIdx].offsetWidth || cell.offsetWidth || 120);
        document.addEventListener('mousemove', onMove);
        document.addEventListener('mouseup', onUp, { once: true });
        e.preventDefault();
      });
    });
  }
})();
</script>
#+end_export


*** bubble-sort

{{< tikztwo >}}

\usepackage[ruled,vlined]{algorithm2e} % Include the package with options

\begin{document}

\begin{algorithm}[H] % [H] for "here", trying to place it exactly here
\SetAlgoLined % Adds lines between instructions
\KwData{Input list $L$}
\KwResult{Sorted list $L$}
\caption{Bubble Sort Algorithm}
\label{alg:bubble_sort}

\For{$i \gets 1$ \KwTo $length(L)-1$}{
    \For{$j \gets 1$ \KwTo $length(L)-i$}{
        \If{$L[j] > L[j+1]$}{
            Swap $L[j]$ and $L[j+1]$\;
        }
    }
}
\Return{$L$}\;
\end{algorithm}

\end{document}
{{< /tikztwo >}}

** org table :noexport:
|           | time                                                                | space                  |
| algorithm | best               | average             | worst                    | worst                  |
| quicksort | $\Omega(n\log(n))$ | $\theta(n \log(n))$ | $\mathcal{O}(n^2)$       | $\mathcal{O}(\log(n))$ |
| mergesort | $\Omega(n\log(n))$ | $\theta(n \log(n))$ | $\mathcal{O}(n \log(n))$ | $\mathcal{O}(n)$       |
| timsort   | $\Omega(n)$        | $\theta(n \log(n))$ | $\mathcal{O}(n \log(n))$ | $\mathcal{O}(n)$       |
| heap      | $\Omega(n\log(n))$ | $\theta(n \log(n))$ | $\mathcal{O}(n \log(n))$ | $\mathcal{O}(1)$       |
| bubble    | $\Omega(n)$        | $\theta(n^2)$       | $\mathcal{O}(n^2)$       | $\mathcal{O}(1)$       |
| insertion | $\Omega(n)$        | $\theta(n^2)$       | $\mathcal{O}(n \log(n))$ | $\mathcal{O}(1)$       |
| selection | $\Omega(n^2)$      | $\theta(n^2)$       | $\mathcal{O}(n^2)$       | $\mathcal{O}(1)$       |
| bucket    | $\Omega(n+k)$      | $\theta(n+k)$       | $\mathcal{O}(n^2)$       | $\mathcal{O}(n)$       |
| radix     | $\Omega(nk)$       | $\theta(nk)$        | $\mathcal{O}(nk)$        | $\mathcal{O}(n+k)$     |




*** Insertion Sort

*** Selection Sort

*** Quicksort

worst-case space: O(1)
worst-case time: O(n^2)

*** Merge Sort


#+BEGIN_CENTER
{{< tikztwo >}}
\usepackage{fancybox}

\begin{document}
\begin{tikzpicture}[level/.style={sibling distance=60mm/#1}]
\node [circle,draw] (z){$n$}
  child {node [circle,draw] (a) {$\frac{n}{2}$}
    child {node [circle,draw] (b) {$\frac{n}{2^2}$}
      child {node {$\vdots$}
        child {node [circle,draw] (d) {$\frac{n}{2^k}$}}
        child {node [circle,draw] (e) {$\frac{n}{2^k}$}}
      } 
      child {node {$\vdots$}}
    }
    child {node [circle,draw] (g) {$\frac{n}{2^2}$}
      child {node {$\vdots$}}
      child {node {$\vdots$}}
    }
  }
  child {node [circle,draw] (j) {$\frac{n}{2}$}
    child {node [circle,draw] (k) {$\frac{n}{2^2}$}
      child {node {$\vdots$}}
      child {node {$\vdots$}}
    }
  child {node [circle,draw] (l) {$\frac{n}{2^2}$}
    child {node {$\vdots$}}
    child {node (c){$\vdots$}
      child {node [circle,draw] (o) {$\frac{n}{2^k}$}}
      child {node [circle,draw] (p) {$\frac{n}{2^k}$}
        child [grow=right] {node (q) {$=$} edge from parent[draw=none]
          child [grow=right] {node (q) {$O_{k = \lg n}(n)$} edge from parent[draw=none]
            child [grow=up] {node (r) {$\vdots$} edge from parent[draw=none]
              child [grow=up] {node (s) {$O_2(n)$} edge from parent[draw=none]
                child [grow=up] {node (t) {$O_1(n)$} edge from parent[draw=none]
                  child [grow=up] {node (u) {$O_0(n)$} edge from parent[draw=none]}
                }
              }
            }
            child [grow=down] {node (v) {$O(n \cdot \lg n)$}edge from parent[draw=none]}
          }
        }
      }
    }
  }
};
\path (a) -- (j) node [midway] {+};
\path (b) -- (g) node [midway] {+};
\path (k) -- (l) node [midway] {+};
\path (k) -- (g) node [midway] {+};
\path (d) -- (e) node [midway] {+};
\path (o) -- (p) node [midway] {+};
\path (o) -- (e) node (x) [midway] {$\cdots$}
  child [grow=down] {
    node (y) {$O\left(\displaystyle\sum_{i = 0}^k 2^i \cdot \frac{n}{2^i}\right)$}
    edge from parent[draw=none]
  };
\path (q) -- (r) node [midway] {+};
\path (s) -- (r) node [midway] {+};
\path (s) -- (t) node [midway] {+};
\path (s) -- (l) node [midway] {=};
\path (t) -- (u) node [midway] {+};
\path (z) -- (u) node [midway] {=};
\path (j) -- (t) node [midway] {=};
\path (y) -- (x) node [midway] {$\Downarrow$};
\path (v) -- (y)
  node (w) [midway] {$O\left(\displaystyle\sum_{i = 0}^k n\right) = O(k \cdot n)$};
\path (q) -- (v) node [midway] {=};
\path (e) -- (x) node [midway] {+};
\path (o) -- (x) node [midway] {+};
\path (y) -- (w) node [midway] {$=$};
\path (v) -- (w) node [midway] {$\Leftrightarrow$};
\path (r) -- (c) node [midway] {$\cdots$};
\end{tikzpicture}
\end{document}
{{< /tikztwo >}}
#+END_CENTER


*** Bucket Sort

*** Bubblesort

*** Bogosort

** Footnotes

[fn:1] these time complexities, along with a number of others were taken from [[https://bigocheatsheet.com]].
