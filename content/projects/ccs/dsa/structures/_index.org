+++
title = "Data Structures"
tags = ["primitive", "arrays", "strings", "linked-lists", "stacks", "queues", "hash-tables", "trees", "heaps", "graphs"]
tikzajax = "true"
toc = "true"
math = "true"
+++

{{< collapse id="data-structures" folded="false" >}}

I am actually thinking of collapsing all of the nested files / folders that each represent a data structure into this one huge document. This way I can see everything all at once laid out in front of me and make use of the **toggling** feature of this site along with the floating /table of contents/ and margin-notes!

The inspiration is my computer vision [[/projects/computer-vision][notes]].

** at a glance:

#+begin_export html
<style>
  table.ds-table { width: 100%; border-collapse: collapse; table-layout: auto; }
  .ds-table th, .ds-table td { border: 1px solid var(--table-border, #ddd); padding: .5rem .6rem; vertical-align: middle; }
  .ds-table thead th { background: var(--table-head-bg, #ECDBB2); position: relative; user-select: none; }
  .ds-table th[colspan] { text-align: center; }
  .ds-table th[rowspan] { text-align: left; }

  /* Don’t wrap complexity tokens; allow DS names to wrap */
  .ds-table td:not(.ds-name) { white-space: nowrap; }
  .ds-table td.ds-name { white-space: normal; }

  /* Sorting affordance */
  .sort-click { cursor: pointer; }
  .sort-click::after { content: " ⇅"; opacity: .5; font-size: .9em; }

  /* Resizer handle (full-height sliver at the right edge of each header cell) */
  .col-resizer {
    position: absolute; right: -3px; top: 0; width: 6px; height: 100%;
    cursor: col-resize; z-index: 1;
  }
  .col-resizer:hover { background: rgba(0,0,0,.08); }

  /* While dragging: add a guide line */
  .resizing .col-guide {
    position: absolute; top: 0; bottom: 0; width: 0; border-right: 2px dashed rgba(0,0,0,.25);
    pointer-events: none;
  }

  /* Complexity chips */
.ds-table code {
  display: inline-block;
  padding: .05rem .35rem;
  border-radius: .35rem;
  font-weight: 400;
  line-height: 1.2;
  background: var(--chip-bg, transparent);
  color: #000;               /* all chosen colors read well with black text */
  border: 1px solid rgba(0,0,0,.08);
}

</style>

<table class="ds-table" id="ds-table">
  <!-- IMPORTANT: one <col> per column so every column can be resized -->
  <colgroup>
    <col style="width: 22%"><!-- 0: Data Structure -->
    <col style="width: 9%"><!-- 1: Avg Access -->
    <col style="width: 9%"><!-- 2: Avg Search -->
    <col style="width: 9%"><!-- 3: Avg Insert -->
    <col style="width: 9%"><!-- 4: Avg Delete -->
    <col style="width: 9%"><!-- 5: Worst Access -->
    <col style="width: 9%"><!-- 6: Worst Search -->
    <col style="width: 9%"><!-- 7: Worst Insert -->
    <col style="width: 9%"><!-- 8: Worst Delete -->
    <col style="width: 12%"><!-- 9: Space Worst -->
  </colgroup>
  <thead>
    <tr>
      <th rowspan="3" class="sort-click" data-col="0" data-type="alpha">Data Structure
        <span class="col-resizer" data-col="0"></span>
      </th>
      <th colspan="8">Time Complexity</th>
      <th rowspan="3" class="sort-click" data-col="9" data-type="alpha">Space Complexity (Worst)
        <span class="col-resizer" data-col="9"></span>
      </th>
    </tr>
    <tr>
      <th colspan="4">Average</th>
      <th colspan="4">Worst</th>
    </tr>
    <tr>
      <th class="sort-click" data-col="1" data-type="alpha">Access <span class="col-resizer" data-col="1"></span></th>
      <th class="sort-click" data-col="2" data-type="alpha">Search <span class="col-resizer" data-col="2"></span></th>
      <th class="sort-click" data-col="3" data-type="alpha">Insertion <span class="col-resizer" data-col="3"></span></th>
      <th class="sort-click" data-col="4" data-type="alpha">Deletion <span class="col-resizer" data-col="4"></span></th>
      <th class="sort-click" data-col="5" data-type="alpha">Access <span class="col-resizer" data-col="5"></span></th>
      <th class="sort-click" data-col="6" data-type="alpha">Search <span class="col-resizer" data-col="6"></span></th>
      <th class="sort-click" data-col="7" data-type="alpha">Insertion <span class="col-resizer" data-col="7"></span></th>
      <th class="sort-click" data-col="8" data-type="alpha">Deletion <span class="col-resizer" data-col="8"></span></th>
    </tr>
  </thead>
  <tbody>
    <!-- Array -->
    <tr>
      <td class="ds-name"><a href="http://en.wikipedia.org/wiki/Array_data_structure">Array</a></td>
      <td><code class="green">&Theta;(1)</code></td>
      <td><code class="yellow">&Theta;(n)</code></td>
      <td><code class="yellow">&Theta;(n)</code></td>
      <td><code class="yellow">&Theta;(n)</code></td>
      <td><code class="green">O(1)</code></td>
      <td><code class="yellow">O(n)</code></td>
      <td><code class="yellow">O(n)</code></td>
      <td><code class="yellow">O(n)</code></td>
      <td><code class="yellow">O(n)</code></td>
    </tr>
    <!-- Stack -->
    <tr>
      <td class="ds-name"><a href="http://en.wikipedia.org/wiki/Stack_(abstract_data_type)">Stack</a></td>
      <td><code class="yellow">&Theta;(n)</code></td>
      <td><code class="yellow">&Theta;(n)</code></td>
      <td><code class="green">&Theta;(1)</code></td>
      <td><code class="green">&Theta;(1)</code></td>
      <td><code class="yellow">O(n)</code></td>
      <td><code class="yellow">O(n)</code></td>
      <td><code class="green">O(1)</code></td>
      <td><code class="green">O(1)</code></td>
      <td><code class="yellow">O(n)</code></td>
    </tr>
    <!-- Queue -->
    <tr>
      <td class="ds-name"><a href="http://en.wikipedia.org/wiki/Queue_(abstract_data_type)">Queue</a></td>
      <td><code class="yellow">&Theta;(n)</code></td>
      <td><code class="yellow">&Theta;(n)</code></td>
      <td><code class="green">&Theta;(1)</code></td>
      <td><code class="green">&Theta;(1)</code></td>
      <td><code class="yellow">O(n)</code></td>
      <td><code class="yellow">O(n)</code></td>
      <td><code class="green">O(1)</code></td>
      <td><code class="green">O(1)</code></td>
      <td><code class="yellow">O(n)</code></td>
    </tr>
    <!-- Singly Linked List -->
    <tr>
      <td class="ds-name"><a href="http://en.wikipedia.org/wiki/Singly_linked_list#Singly_linked_lists">Singly-Linked List</a></td>
      <td><code class="yellow">&Theta;(n)</code></td>
      <td><code class="yellow">&Theta;(n)</code></td>
      <td><code class="green">&Theta;(1)</code></td>
      <td><code class="green">&Theta;(1)</code></td>
      <td><code class="yellow">O(n)</code></td>
      <td><code class="yellow">O(n)</code></td>
      <td><code class="green">O(1)</code></td>
      <td><code class="green">O(1)</code></td>
      <td><code class="yellow">O(n)</code></td>
    </tr>
    <!-- Doubly Linked List -->
    <tr>
      <td class="ds-name"><a href="http://en.wikipedia.org/wiki/Doubly_linked_list">Doubly-Linked List</a></td>
      <td><code class="yellow">&Theta;(n)</code></td>
      <td><code class="yellow">&Theta;(n)</code></td>
      <td><code class="green">&Theta;(1)</code></td>
      <td><code class="green">&Theta;(1)</code></td>
      <td><code class="yellow">O(n)</code></td>
      <td><code class="yellow">O(n)</code></td>
      <td><code class="green">O(1)</code></td>
      <td><code class="green">O(1)</code></td>
      <td><code class="yellow">O(n)</code></td>
    </tr>
    <!-- Hash Table -->
    <tr>
      <td class="ds-name"><a href="http://en.wikipedia.org/wiki/Hash_table">Hash Table</a></td>
      <td><code class="gray">N/A</code></td>
      <td><code class="green">&Theta;(1)</code></td>
      <td><code class="green">&Theta;(1)</code></td>
      <td><code class="green">&Theta;(1)</code></td>
      <td><code class="gray">N/A</code></td>
      <td><code class="yellow">O(n)</code></td>
      <td><code class="yellow">O(n)</code></td>
      <td><code class="yellow">O(n)</code></td>
      <td><code class="yellow">O(n)</code></td>
    </tr>
    <!-- Binary Search Tree -->
    <tr>
      <td class="ds-name"><a href="http://en.wikipedia.org/wiki/Binary_search_tree">Binary Search Tree</a></td>
      <td><code class="yellow-green">&Theta;(log(n))</code></td>
      <td><code class="yellow-green">&Theta;(log(n))</code></td>
      <td><code class="yellow-green">&Theta;(log(n))</code></td>
      <td><code class="yellow-green">&Theta;(log(n))</code></td>
      <td><code class="yellow">O(n)</code></td>
      <td><code class="yellow">O(n)</code></td>
      <td><code class="yellow">O(n)</code></td>
      <td><code class="yellow">O(n)</code></td>
      <td><code class="yellow">O(n)</code></td>
    </tr>
    <!-- B-Tree -->
    <tr>
      <td class="ds-name"><a href="http://en.wikipedia.org/wiki/B_tree">B-Tree</a></td>
      <td><code class="yellow-green">&Theta;(log(n))</code></td>
      <td><code class="yellow-green">&Theta;(log(n))</code></td>
      <td><code class="yellow-green">&Theta;(log(n))</code></td>
      <td><code class="yellow-green">O(log(n))</code></td>
      <td><code class="yellow-green">O(log(n))</code></td>
      <td><code class="yellow-green">O(log(n))</code></td>
      <td><code class="yellow-green">O(log(n))</code></td>
      <td><code class="yellow-green">O(log(n))</code></td>
      <td><code class="yellow">O(n)</code></td>
    </tr>
    <!-- Red-Black Tree -->
    <tr>
      <td class="ds-name"><a href="http://en.wikipedia.org/wiki/Red-black_tree">Red-Black Tree</a></td>
      <td><code class="yellow-green">&Theta;(log(n))</code></td>
      <td><code class="yellow-green">&Theta;(log(n))</code></td>
      <td><code class="yellow-green">&Theta;(log(n))</code></td>
      <td><code class="yellow-green">&Theta;(log(n))</code></td>
      <td><code class="yellow-green">O(log(n))</code></td>
      <td><code class="yellow-green">O(log(n))</code></td>
      <td><code class="yellow-green">O(log(n))</code></td>
      <td><code class="yellow-green">O(log(n))</code></td>
      <td><code class="yellow">O(n)</code></td>
    </tr>
    <!-- AVL Tree -->
    <tr>
      <td class="ds-name"><a href="http://en.wikipedia.org/wiki/AVL_tree">AVL Tree</a></td>
      <td><code class="yellow-green">&Theta;(log(n))</code></td>
      <td><code class="yellow-green">&Theta;(log(n))</code></td>
      <td><code class="yellow-green">&Theta;(log(n))</code></td>
      <td><code class="yellow-green">&Theta;(log(n))</code></td>
      <td><code class="yellow-green">O(log(n))</code></td>
      <td><code class="yellow-green">O(log(n))</code></td>
      <td><code class="yellow-green">O(log(n))</code></td>
      <td><code class="yellow-green">O(log(n))</code></td>
      <td><code class="yellow">O(n)</code></td>
    </tr>
  </tbody>
</table>

<script>
(function () {
  const table = document.getElementById('ds-table');
  const tbody = table.tBodies[0];
  const colgroup = table.querySelector('colgroup');
  const cols = Array.from(colgroup.children); // one <col> per column (0..9)

  /* ---------- Sorting ---------- */
  const latexKey = s => (s || "")
      .replace(/&[A-Za-z]+;|\u03A9|\u0398|\u2130/g, m => m) // keep greek entities if any
      .replace(/[{}$]/g,'').replace(/\\[a-zA-Z]+/g,'')
      .replace(/\s+/g,' ').trim().toLowerCase();

  const state = {};
  function sortBy(col, dir, type='alpha') {
    const rows = Array.from(tbody.rows);
    const mul = dir === 'desc' ? -1 : 1;
    rows.sort((r1, r2) => {
      let a = r1.cells[col]?.innerText || "";
      let b = r2.cells[col]?.innerText || "";
      if (type === 'num') {
        const na = parseFloat(a.replace(/[^\d.\-eE]/g,'')) || 0;
        const nb = parseFloat(b.replace(/[^\d.\-eE]/g,'')) || 0;
        return (na - nb) * mul;
      }
      a = latexKey(a); b = latexKey(b);
      return (a < b ? -1 : a > b ? 1 : 0) * mul;
    });
    rows.forEach(r => tbody.appendChild(r));
  }

  table.querySelectorAll('.sort-click').forEach(th => {
    th.addEventListener('click', () => {
      const col = +th.dataset.col;
      const type = th.dataset.type || 'alpha';
      const next = state[col] === 'asc' ? 'desc' : 'asc';
      state[col] = next;
      sortBy(col, next, type);
    });
  });

  /* ---------- Column Resizing (works for ALL columns) ---------- */
  // Strategy: we place a handle on each header cell that maps to a leaf column index.
  // Dragging sets that <col>'s width in px. If Shift is held, we also shrink/grow the next column to keep table width steady.

  // Build a map from header resizer to true column index taking colspans into account.
  // Easiest in our layout: the "leaf" headers are the last THEAD row; prepend Data Structure (0) manually.
  const leafRow = table.tHead.rows[2];
  const leafStarts = [0]; // col indices: 0 first, then 1..8 from leafRow
  {
    let idx = 1;
    for (const th of leafRow.cells) {
      const span = th.colSpan || 1;
      leafStarts.push(idx);
      idx += span;
    }
    // leafStarts now [0,1,2,3,4,5,6,7,8,9] length 10
  }

  // Visual guide while dragging
  let guide = null;

  function px(n) { return Math.max(60, Math.round(n)); } // min width 60px

  function startDrag(e, targetCol) {
    const startX = e.clientX;
    const startW = cols[targetCol].offsetWidth || table.tHead.getBoundingClientRect().width / cols.length;
    const nextCol = (e.shiftKey && targetCol < cols.length - 1) ? targetCol + 1 : null;
    const startWNext = nextCol != null ? (cols[nextCol].offsetWidth || 0) : 0;

    table.classList.add('resizing');
    guide = document.createElement('div');
    guide.className = 'col-guide';
    // Place guide at current boundary
    const thCell = getHeaderCellFor(targetCol);
    const rect = thCell.getBoundingClientRect();
    guide.style.left = (rect.right - table.getBoundingClientRect().left) + 'px';
    table.style.position = table.style.position || 'relative';
    table.appendChild(guide);

    function onMove(ev) {
      const dx = ev.clientX - startX;
      const newW = px(startW + dx);
      cols[targetCol].style.width = newW + 'px';

      if (nextCol != null) {
        const newNext = px(startWNext - dx);
        cols[nextCol].style.width = newNext + 'px';
      }
      // Move guide to current boundary of target column
      const thNow = getHeaderCellFor(targetCol);
      const r = thNow.getBoundingClientRect();
      guide.style.left = (r.right - table.getBoundingClientRect().left) + 'px';
    }

    function onUp() {
      document.removeEventListener('mousemove', onMove);
      document.removeEventListener('mouseup', onUp);
      table.classList.remove('resizing');
      if (guide) { guide.remove(); guide = null; }
    }
    document.addEventListener('mousemove', onMove);
    document.addEventListener('mouseup', onUp);
  }

  function getHeaderCellFor(colIndex) {
    // Try last-row leaf header if in 1..8; otherwise the big first/last headers.
    if (colIndex === 0) return table.tHead.rows[0].cells[0];
    if (colIndex === 9) return table.tHead.rows[0].cells[table.tHead.rows[0].cells.length - 1];
    // For 1..8, map to leafRow.cell[colIndex-1]
    return leafRow.cells[colIndex - 1];
  }
  /* ---------- Complexity coloring ---------- */
  // Your palette:
  const chipColors = {
    on2:     '#FF8989', // O(n^2)
    onlogn:  '#FFC542', // O(n log n)
    logn:    '#C8EA01', // O(log n)
    n:       '#FFFF02', // O(n)
    one:     '#54D002', // O(1)
    na:      '#ECDBB2'  // N/A
  };

  // Normalize cell text (handles O/Θ/Ω, LaTeX, entities, whitespace)
  function normComplexity(text) {
    let s = (text || '').toLowerCase();

    // strip LaTeX wrappers: \mathcal{O}, \Theta, \Omega, etc.
    s = s.replace(/\\mathcal\{o\}|\&omicron;|o/g, 'o')
         .replace(/\\theta|&theta;|θ/g, 'theta')
         .replace(/\\omega|&omega;|ω/g, 'omega')
         .replace(/[{}$]/g, '')
         .replace(/\\log/g, 'log')
         .replace(/\s+/g, '');

    // Also support HTML entities like &Theta; &Omega;
    s = s.replace(/&theta;|\\theta/g, 'theta')
         .replace(/&omega;|\\omega/g, 'omega');

    // Normalize typical variants to a small set
    // e.g., o(n\log n) -> o(nlogn), theta(n log(n)) -> theta(nlogn)
    s = s.replace(/log\(?n\)?/g, 'logn');

    // Map to buckets (order matters: test more specific first)
    if (/n\^?2/.test(s))             return 'on2';
    if (/nlogn/.test(s))             return 'onlogn';
    if (/^o?\(?logn\)?|^theta\(logn\)|^omega\(logn\)/.test(s)) return 'logn';
    if (/^o?\(?n\)?|^theta\(n\)|^omega\(n\)/.test(s))          return 'n';
    if (/^o?\(?1\)?|^theta\(1\)|^omega\(1\)/.test(s))          return 'one';
    if (/na|n\/a/.test(s))           return 'na';

    // Unknown forms (e.g., O(n+k), O(nk)) -> leave as-is
    return null;
  }

  function applyComplexityColors(root) {
    root.querySelectorAll('code').forEach(code => {
      const t = code.textContent || code.innerText || '';
      const bucket = normComplexity(t);
      if (!bucket) return;
      code.style.setProperty('--chip-bg', chipColors[bucket]);
      code.style.background = chipColors[bucket];
      code.title = ({
        on2: 'O(n²)',
        onlogn: 'O(n log n)',
        logn: 'O(log n)',
        n: 'O(n)',
        one: 'O(1)',
        na: 'N/A'
      })[bucket];
    });
  }

  // Run once now; re-run after client-side math renderers if you use them dynamically
  applyComplexityColors(table);


  
  // Bind resizers (handles exist on every header cell; their data-col already set for 0..9)
  table.querySelectorAll('.col-resizer').forEach(handle => {
    handle.addEventListener('mousedown', e => {
      const colIdx = +handle.dataset.col;
      if (Number.isInteger(colIdx) && cols[colIdx]) {
        startDrag(e, colIdx);
        e.preventDefault();
      }
    });
  });
})();
</script>
#+end_export


** primitives
:PROPERTIES:
:CUSTOM_ID: primitives
:END:


*** schematic/s

#+BEGIN_CENTER
#+CAPTION: ieee 754 floating point representation
{{< tikztwo >}}
\usetikzlibrary{shapes.multipart, calc, decorations.pathreplacing}

\begin{document}
\begin{tikzpicture}[scale=2.2,transform shape,array/.style={rectangle split,rectangle split horizontal, rectangle split parts=#1,draw, anchor=center, rectangle split part fill={blue!20, green!20, blue!20!green!90}}]
\node[array=3] (a) {
\nodepart{one}0
\nodepart{two}01001100
\nodepart{three}01001111000000001111111
};

\draw [decoration={brace,raise=2pt},decorate] ($(a.two) + (-0.13,+0.35)$) --  node[above=3pt]{Exponent (8 bit)}($(a.three) + (-0.13,+0.35)$);
\draw [decoration={brace,mirror,raise=2pt},decorate] ($(a.three) + (-0.13,-0.14)$) --  node[below=3pt]{Mantissa (23 bit)}(a.south east);
\draw [decoration={brace,mirror,raise=2pt},decorate] ($(a.one) + (-0.13,-0.14)$) --  node[below=3pt]{Sign (1 bit)}($(a.two) + (-0.13,-0.15)$);
\end{tikzpicture}
\end{document}
{{< /tikztwo >}}
#+END_CENTER

#+BEGIN_CENTER
#+CAPTION: two's complement for a 4 bit value
{{< tikztwo >}}
\usetikzlibrary{shadows}  % Used library shadows of the tikz package
\begin{document}
\begin{tikzpicture}[scale=1.5,transform shape,
     auto,                % some style definitions of the elements follow
     node distance = 0cm, % used in this picture
     bin/.style    = {rectangle, fill=white, text=black},
     dec/.style    = {draw=none, text=black},
    circ/.style    = {circle, top color=white, bottom color=blue!50,
    draw=blue, very thin, minimum size=5.25cm, drop shadow={opacity=0.5}}
  ]
  % draw a grid in the background
  \draw[step=1,gray,thin] (-4,-4) grid (4,4);
  \node[circ] (center) at (0,0)  {};
  \node[font=\sffamily]   (4bit)   at (0,.5) {4 bit};

  % Simply hand calculated angles for the positions of the bit values
  %varound the circle

  \foreach \angle / \bits in {%
      0/0000, 22.5/0001, 45/0010, 67.5/0011, 90/0100, 112.5/0101,
    135/0110, 157.5/0111, 180/1000, 202.5/1001, 225/1010, 247.5/1011,
    270/1100, 292.5/1101, 315/1110, 337.5/1111}
    \draw (\angle:3.25cm) node [bin, font=\ttfamily] {\bits};

  \draw[fill=red, opacity=.25]
    (-4,-4) -- (-4cm,.8cm) -- (4cm,-0.7cm) -- (4cm,-4cm) -- cycle;

  % Simply hand calculated angles for the positions of
  % the decimal values around the circle

  \foreach \angle / \dez in {%
    0/0, 22.5/1, 45/2, 67.5/3, 90/4, 112.5/5, 135/6, 157.5/7, 180/-8,
    202.5/-7, 225/-6, 247.5/-5, 270/-4, 292.5/-3, 315/-2, 337.5/-1}
    \draw (\angle:2.25cm) node [dec, font=\sffamily] {\dez};

  \foreach \angle / \bits in {%
      0/0000, 22.5/0001, 45/0010, 67.5/0011, 90/0100, 112.5/0101,
    135/0110, 157.5/0111, 180/1000, 202.5/1001, 225/1010, 247.5/1011,
    270/1100, 292.5/1101, 315/1110, 337.5/1111}
    \draw (\angle:3.25cm) node [bin, fill=none, font=\ttfamily] {\bits};
\end{tikzpicture}
\end{document}
{{< /tikztwo >}}
#+END_CENTER

*** python


| type       | example         |
|------------+-----------------|
| =int=      | 32              |
| =float=    | 3.2             |
| =complex=  | (3+2j)          |
| =bool=     | False           |
| =str=      | "Hello World!"  |
| =bytes=    | b'\x00\x00\x00' |
| =NoneType= | None            |
|------------+-----------------|


*** java


| type      |                                size (bits) | description                      | usage                  |
|-----------+--------------------------------------------+----------------------------------+------------------------|
| =byte=    |                                          8 | -128 to 127                      | =byte b = 100;=        |
| =short=   |                                         16 | -32,768 to 32,767                | =short s = 1000;=      |
| =int=     |                                         32 | -$2^{31}$ to $2^{31}-1$          | =int i = 12345;=       |
| =long=    |                                         64 | -$2^{63}$ to $2^{63}-1$          | =long l = 123456789L;= |
| =float=   |                                         32 | single-precision floating number | =float f = 3.14f;=     |
| =double=  |                                         64 | double-precision floating number | =double d = 3.14159;=  |
| =char=    |                                         16 | single 16-bit unicode character  | =char c = 'A';=        |
| =boolean= | 1bit or 1byte{{< mnote "JVM dependent" >}} | =true= or =false=                | =boolan flag = true;=  |
|-----------+--------------------------------------------+----------------------------------+------------------------|


*** c


| type          | size (bits)                   | description                                | usage                                    |
|---------------+-------------------------------+--------------------------------------------+------------------------------------------|
| =char=        | typically 8                   | character type (smallest addressable unit) | =char c = 'A';=                          |
| =short=       | typically 16                  | short integer                              | =short s = 1000;=                        |
| =int=         | typically 32                  | integer number                             | =int i = 42;=                            |
| =long=        | typically 32 or 64            | long integer                               | =long l = 123456L;=                      |
| =long long=   | typically $\geq$64            | extended-precision integer                 | =long long ll = 123456789LL;=            |
| =float=       | typically 32                  | single-precision floating number           | =float f = 3.14f;=                       |
| =double=      | typically 64                  | double-precision floating number           | =double d = 3.14159;=                    |
| =long double= | $\geq$80 (platform-dependent) | extended-precision floating number         | =long double ld = 3.141592653589793L;=   |
| =_Bool=       | typically 8                   | boolean value (true or false, since C99)   | =_Bool flag = 1;= or =bool flag = true;= |
| =void=        | —                             | represents “no value” or “no type”         | =void functionName();=                   |
|---------------+-------------------------------+--------------------------------------------+------------------------------------------|


** arrays
:PROPERTIES:
:CUSTOM_ID: arrays
:END:


*** schematic

{{< tikztwo >}}
\usetikzlibrary{shapes.multipart, calc}

\begin{document}
\begin{tikzpicture}[xscale=5,yscale=5,transform shape, array/.style={rectangle split,rectangle split horizontal, rectangle split parts=#1,draw, anchor=center}]
\node[array=5] (a) {
\nodepart{one}d
\nodepart{two}
\nodepart{three}c
\nodepart{four}c
\nodepart{five}b
};
\node[color=gray, anchor=north, yshift=-0.5] at (a.one)   {\tiny $0$};
\node[color=gray, anchor=north, yshift=-2] at (a.two)   {\tiny $1$};
\node[color=gray, anchor=north, yshift=-2] at (a.three) {\tiny $2$};
\node[color=gray, anchor=north, yshift=-2] at (a.four)  {\tiny $3$};
\node[color=gray, anchor=north, yshift=-0.5] at (a.five)  {\tiny $4$};
\end{tikzpicture}
\end{document}
{{< /tikztwo >}}

*** time complexity


|         | Access           | Search           | Insertion        | Deletion         |
|---------+------------------+------------------+------------------+------------------|
| Average | $\mathcal{O}(1)$ | $\mathcal{O}(n)$ | $\mathcal{O}(n)$ | $\mathcal{O}(n)$ |
| Worst   | .                | .                | .                | .                |
|---------+------------------+------------------+------------------+------------------|

explanations are warranted for these. **access** will be thought of as the time complexity required to sequentially access the $k$th item in the data-structure.

to "access" the $k$th item we can index into the array: constant time

*searching* for a particular key is not something we can do intelligently in this contiguous block of memory, so we must check all $n$ items.

insertion would /on average/ take $\dfrac n2$ time, but because we are working with asymptotics, the constant disappears. the worst case is insertion at the front of the array with every subsequent item having to be moved into the $k+1$th position.

deletion follows a similiar argument with worst-case being deletion of the first element, and the average case decaying to the worst-case bounds asymptotically.


*** space complexity

this is less of a question when you have a data structure, as opposed to an [[/projects/ccs/dsa/classical][algorithm]], because with $n$ elements you will have to store all of them uniquely. as such for arrays and all data structures on this page {{< mnote "except skip lists" >}} we have $\mathcal{O}(n)$ space complexity.


*** operations

naturally, whilst we are considering *access*, *search*, *insertion* and *deletion* operations on this page, an *array* is represented in /Python/ as a list. these lists have the following methods:

| method                 | explanation                                      |
|------------------------+--------------------------------------------------|
| =append()=             | adds an element to the /end/ of the list         |
| =clear()=              | removes all the elements from the list           |
| =copy()=               | returns a copy of the list                       |
| =count(arg)=           | returns the number of elements with value of arg |
| =extend(another_list)= | add the elements of another list to this list    |
| =index(arg)=           | return index of /first/ element with arg value   |
| =insert(arg)=          | add element at arg position                      |
| =pop(arg)=             | remove element at arg position                   |
| =remove()=             | remove first item with specified value           |
| =reverse()=            | reverses the order of the list                   |
| =sort()=               | sorts the list in place. mutates array           |

** linked lists
:PROPERTIES:
:CUSTOM_ID: linked-lists
:END:


*** singly linked list
:PROPERTIES:
:CUSTOM_ID: singly-ll
:END:

**** schematic
{{< tikztwo >}}
\usetikzlibrary{chains,shapes}

\newcommand{\chainlabel}[2]{\path [<-, draw, shorten >=10pt] (#1) |- node [at end] {#2} ++(-1,1);}

\begin{document}
\begin{tikzpicture}[scale=2,transform shape,every node/.style={rectangle split, rectangle split parts=2, rectangle split horizontal,minimum height=14pt}, node distance=1em, start chain,
 every join/.style={->, shorten <=-4.5pt}]

 \node[draw, on chain, join] { 1  };
 \node[draw, on chain, join] { 7  };
 \node[draw, on chain, join] { 5  };
 \node[draw, on chain, join] { 2  };
 \node[draw, on chain, join] {};
\chainlabel{chain-1.one north}{head};
\end{tikzpicture}  

\end{document}
{{< /tikztwo >}}


{{< tikztwo >}}
\usepackage{tikz}
\usetikzlibrary{calc,shapes.multipart,chains,arrows}

\tikzset{
    squarecross/.style={
        draw, rectangle,minimum size=18pt, fill=orange!80,
        inner sep=0pt, text=black,
        path picture = {
            \draw[black]
            (path picture bounding box.north west) --
            (path picture bounding box.south east)
            (path picture bounding box.south west) --
            (path picture bounding box.north east);
        }
    }
}

\begin{document}
\begin{tikzpicture}[scale=2,transform shape,
        list/.style={
            very thick, rectangle split,
            rectangle split parts=2, draw,
            rectangle split horizontal, minimum size=18pt,
            inner sep=4pt, text=black,
            rectangle split part fill={red!20, blue!20}
        },
        ->, start chain, very thick
      ]

  \node[list,on chain] (A) {12};
  \node[list,on chain] (B) {99};
  \node[list,on chain] (C) {37};
  \node[squarecross]   (D) [right=of C] {};
  \draw[*->] let \p1 = (A.two), \p2 = (A.center) in (\x1,\y2) -- (B);
  \draw[*->] let \p1 = (B.two), \p2 = (B.center) in (\x1,\y2) -- (C);
  \draw[*->] let \p1 = (C.two), \p2 = (C.center) in (\x1,\y2) -- (D);
\end{tikzpicture}
\end{document}
{{< /tikztwo >}}


**** time complexity


|         | Access           | Search           | Insertion        | Deletion         |
|---------+------------------+------------------+------------------+------------------|
| Average | $\mathcal{O}(n)$ | $\mathcal{O}(n)$ | $\mathcal{O}(1)$ | $\mathcal{O}(1)$ |
| Worst   | .                | .                | .                | .                |
|---------+------------------+------------------+------------------+------------------|

once again, explanations are necessary:
- to access a $k$th item, we need to start at the =head= and make our way to this item; hence $\mathcal{O}(n)$ for *access*
- same for *search*; even if you know which item you want, there is no way of knowing where it is. you have to traverse from the =head=.
- the very act of *insertion* will take constant time. if you wish to find a "middle" item and then insert there, the complexity would be $\mathcal{O}(n)$, but here we are decoupling the operations
- same as above. simply freeing memory / *deleting* a node will take constant time.

*** doubly linked lists

**** schematic

{{< tikztwo >}}

\usetikzlibrary{calc,shapes.multipart,chains,arrows,positioning}

\tikzset{
    squarecross/.style={
        draw, rectangle,minimum size=18pt, fill=orange!80,
        inner sep=0pt, text=black,
        path picture = {
            \draw[black]
            (path picture bounding box.north west) --
            (path picture bounding box.south east)
            (path picture bounding box.south west) --
            (path picture bounding box.north east);
        }
    }
}

\begin{document}
\begin{tikzpicture}[scale=2,transform shape,
        list/.style={
            very thick, rectangle split,
            rectangle split parts=3, draw,
            rectangle split horizontal, minimum size=18pt,
            inner sep=5pt, text=black,
            rectangle split part fill={blue!20, red!20, blue!20}
        },
        ->, start chain, very thick
      ]

  \node[list,on chain] (A) {\nodepart{second} 12};
  \node[list,on chain] (B) {\nodepart{second} 99};
  \node[list,on chain] (C) {\nodepart{second} 37};

  \node[squarecross]   (D) [right=of C] {};
  \node[squarecross]   (E) [left= of A] {};

  \path[*->] let \p1 = (A.three), \p2 = (A.center) in (\x1,\y2) edge [bend left] ($(B.one)+(0,0.2)$);
  \path[*->] let \p1 = (B.three), \p2 = (B.center) in (\x1,\y2) edge [bend left] ($(C.one)+(0,0.2)$);
  \draw[*->] let \p1 = (C.three), \p2 = (C.center) in (\x1,\y2) -- (D);

  \draw[*->] ($(A.one)+(0.2,0.1)$) -- (E);
  \path[*->] ($(B.one)+(0.1,0.1)$) edge [bend left] ($(A.three)+(0,-0.05)$);
  \path[*->] ($(C.one)+(0.1,0.1)$) edge [bend left] ($(B.three)+(0,-0.05)$);
\end{tikzpicture}
\end{document}
{{< /tikztwo >}}

**** time complexity


|         | Access           | Search           | Insertion        | Deletion         |
|---------+------------------+------------------+------------------+------------------|
| Average | $\mathcal{O}(n)$ | $\mathcal{O}(n)$ | $\mathcal{O}(1)$ | $\mathcal{O}(1)$ |
| Worst   | .                | .                | .                | .                |
|---------+------------------+------------------+------------------+------------------|

with respect to the asymptotics of operations, the doubly linked list provides no advantage over the [[#singly-ll][singly linked list]].

*** tradeoffs

non-contiguous use of memory is an advantage in terms of finding more memory for nodes, but is also a disadvantage in terms of *traversal*.


*** strings
:PROPERTIES:
:CUSTOM_ID: strings
:END:

strings really are just /special cases/ of arrays. but because their operations vary so wildly from the usual array operations:
- concatenation
- joining
- comparison
- splitting
- searching for substrings

it makes sense for this topic to have its own little nook.

this page is not about algorithms, and so there is nothing really novel to add here at the moment, but a number of clever algorithms will relate back to this heading.

** stacks & queues


*** stack
:PROPERTIES:
:CUSTOM_ID: stack
:END:

**** schematic
{{< tikztwo >}}
\usetikzlibrary{shapes.multipart}
\begin{document}
\begin{tikzpicture}[scale=2,transform shape,stack/.style={rectangle split, rectangle split parts=#1, draw, anchor=center, minimum width=1cm}]
    \node[draw, minimum width=1cm, minimum height=0.5cm] (in) at (-1,2) {};
    \node[draw, minimum width=1cm, minimum height=0.5cm] (out) at (1,2) {};
    
    \node[stack=4] (stack) at (0,0.17) {
        \nodepart{one} 
        \nodepart{two} 
        \nodepart{three} 
        \nodepart{four}
    };

    \draw[-latex] (0.25,1) .. controls (0.25,1.5) and (1,1.5) .. (out.south);
    \draw[-latex] (in.south) .. controls (-1,1.5) and (-0.25,1.5) .. (-0.25,1);
\end{tikzpicture}
\end{document}
{{< /tikztwo >}}


**** time complexity


|         | Access           | Search           | Insertion        | Deletion         |
|---------+------------------+------------------+------------------+------------------|
| Average | $\mathcal{O}(n)$ | $\mathcal{O}(n)$ | $\mathcal{O}(1)$ | $\mathcal{O}(1)$ |
| Worst   | .                | .                | .                | .                |
|---------+------------------+------------------+------------------+------------------|

as expected:
- random access will take $n$ steps. presumably here we are using a linked list implementation though and so arbitrary accesses will always take (asymptotically) $n$ steps
- similarly search as in an array or linked list requires $n$ steps
- the advantage comes from *inserting* into the stack which always takes constant time
- and *deletion* costs constant time. this is the use-case for this data structure anyhow


*** queue
:PROPERTIES:
:CUSTOM_ID: queue
:END:


**** schematic

{{< tikztwo >}}
\usetikzlibrary{shapes.multipart}
\begin{document}
\begin{tikzpicture}[scale=2,transform shape,queue/.style={rectangle split, rectangle split parts=#1, draw, anchor=center, minimum width=1.5cm}]
    \node[draw, minimum width=1cm, minimum height=0.5cm] (in) at (-2,2) {};
    \node[draw, minimum width=1cm, minimum height=0.5cm] (out) at (2,-2) {};
    
    \node[queue=4] (queue) at (0,0) {
        \nodepart{one} 
        \nodepart{two} 
        \nodepart{three} 
        \nodepart{four}
    };

    \draw[-latex] (queue.south) .. controls (0,-1.5) and (2,-1.5) .. (out.north);
    \draw[-latex] (in.south) .. controls (-2,1.5) and (0,1.5) .. (queue.north);
\end{tikzpicture}
\end{document}
{{< /tikztwo >}}


**** time complexity


|         | Access           | Search           | Insertion        | Deletion         |
|---------+------------------+------------------+------------------+------------------|
| Average | $\mathcal{O}(n)$ | $\mathcal{O}(n)$ | $\mathcal{O}(1)$ | $\mathcal{O}(1)$ |
| Worst   | .                | .                | .                | .                |
|---------+------------------+------------------+------------------+------------------|

this is the same as the [[#stack][stack]]:
- underlying implementation details would be identical, so *access* behaviour wouldn't change
- neither would *search* functionality
- only the location of *insertion*
- and location of *deletion* would change

**** double ended queue (deque)
:PROPERTIES:
:CUSTOM_ID: deque
:END:


this is an interesting data structure. at first I thought it was short for /dequeue/, but it is not. instead this structure is pronounced "deck", and is a list with 2 pointers:

{{< tikztwo >}}
\usepackage{tikz}
\usetikzlibrary{arrows.meta, positioning, shapes.geometric}

\begin{document}
\begin{tikzpicture}[scale=2,transform shape,
    node distance=0mm,
    box/.style={rectangle, draw=blue!60, fill=blue!10, thick, minimum width=1.2cm, minimum height=1cm},
    arrow/.style={-{Stealth[length=3mm]}, thick, red!70},
    label/.style={font=\small\bfseries, red!70}
]

% Title
% Draw the deque elements
\node[box] (n1) at (0,0) {12};
\node[box, right=of n1] (n2) {7};
\node[box, right=of n2] (n3) {23};
\node[box, right=of n3] (n4) {45};
\node[box, right=of n4] (n5) {8};

% Front and Rear labels
\node[below=5mm of n1, font=\small\bfseries, blue!70] {Front};
\node[below=5mm of n5, font=\small\bfseries, blue!70] {Rear};

% Left side operations (Front)
\draw[arrow] (n1.north) -- ++(0, 0.8) node[label, above] {pop\_front()};
\draw[arrow] ([xshift=-3mm]n1.south) -- ++(0, -1.8) node[label, below] {push\_front()};

% Right side operations (Rear)
\draw[arrow] (n5.north) -- ++(0, 0.8) node[label, above] {pop\_back()};
\draw[arrow] ([xshift=3mm]n5.south) -- ++(0, -1.8) node[label, below] {push\_back()};

% Bidirectional arrow showing deque concept
\draw[{Stealth[length=3mm]}-{Stealth[length=3mm]}, thick, green!60!black] 
    ([yshift=-3.0cm]n1.south) -- ([yshift=-3.0cm]n5.south) 
    node[midway, below=5mm, font=\small\bfseries, green!60!black] {Operations allowed at both ends};

\end{tikzpicture}
\end{document}
{{< /tikztwo >}}


** hash tables / hashmaps
:PROPERTIES:
:CUSTOM_ID: hashmaps
:END:

A =map= maintains insertion order.

*** schematic

{{< tikztwo >}}
\begin{document}
\begin{tikzpicture}
    % Define node style
    \tikzset{cell/.style={draw, minimum width=1.8cm, minimum height=1.8cm, anchor=north west}}
    
    % Row 1
    \node[cell] (key1) at (0,0) {Key1};
    \node[cell] (val1) at (1.8,0) {Value1};
    
    % Row 2
    \node[cell] (key2) at (0,-1.8) {Key2};
    \node[cell] (val2) at (1.8,-1.8) {Value2};
    
    % Row 3
    \node[cell] (key3) at (0,-3.6) {Key3};
    \node[cell] (val3) at (1.8,-3.6) {Value3};
\end{tikzpicture}
\end{document}
{{< /tikztwo >}}





*** time complexity



|         | Access | Search           | Insertion        | Deletion         |
|---------+--------+------------------+------------------+------------------|
| Average | n/a    | $\mathcal{O}(1)$ | $\mathcal{O}(1)$ | $\mathcal{O}(1)$ |
| Worst   | .      | $\mathcal{O}(n)$ | $\mathcal{O}(n)$ | $\mathcal{O}(n)$ |
|---------+--------+------------------+------------------+------------------|

obviously the time-complexity depends on the data structure and the way in which it is implemented from an atomic operations point of view.

having said this, hash-tables are sort of a mystery to me at the moment. they have varying implementations and even then I need to study each to understand what the associated compute would look like for each method.

for now I have just copied down what was given at [[bigocheatsheet.com]]

** trees
:PROPERTIES:
:CUSTOM_ID: trees
:END:


*** schematic

{{< tikztwo >}}
\begin{document}
\begin{tikzpicture}[scale=2,transform shape,level distance=1.3cm,
   level 1/.style={sibling distance=3cm, level distance=1cm},
   level 2/.style={sibling distance=1.5cm, level distance=0.8cm}]
\node {Root}
   child {node {Child}
   child {node {Node}}
   child {node {Node}}
}
child {node {Level 2}
   child {node {Level 3}}
   child {node {Level 3}}
};
\end{tikzpicture}
\end{document}
{{< /tikztwo >}}


*** Binary Search Tree

**** schematic

#+BEGIN_CENTER
#+HTML: <div style="display: flex; align-items: center; justify-content: center; gap: 20px;">
#+HTML:   <div style="text-align: center; display: flex; flex-direction: column; align-items: center;">
#+CAPTION: binary-tree, unsorted.
#+ATTR_HTML: :width 350px :class lateximage
{{< tikztwo >}}
\usetikzlibrary{arrows,positioning, calc}
\tikzstyle{vertex}=[draw,fill=black!15,circle,minimum size=20pt,inner sep=0pt]
\begin{document}
\begin{tikzpicture}[scale=1,transform shape,very thick,level/.style={sibling distance=60mm/#1}]
\node [vertex] (r){$17$}
  child {
    node [vertex] (a) {$19$}
    child {
      node [vertex] {$20$}
      child {
        node [vertex] {$-3$}
        child {node [vertex] {$17$}}
        child {node [vertex] {$5$}}
      }
      child {node [vertex] {$6$}}
    }
    child {
      node [vertex] {$3$}
      child {node [vertex] {$7$}}
      child {node [vertex] {$2$}}
    }
  }
  child {
    node [vertex] {$9$}
    child {
      node [vertex] {$8$}
      child {node [vertex] {$2$}}
    }
    child {
      node [vertex] {$11$}
      child {node [vertex] {$17$}}
      child {node [vertex] {$-4$}}
    }
  };
\end{tikzpicture}
\end{document}
{{< /tikztwo >}}
#+HTML:   </div>
#+HTML:   <div style="text-align: center; display: flex; flex-direction: column; align-items: center;">
#+CAPTION: binary *search* tree (sorted)
#+ATTR_HTML: :width 350px :class lateximage
{{< tikztwo >}}
\usetikzlibrary{arrows,positioning,calc}
\tikzstyle{vertex}=[draw,fill=black!15,circle,minimum size=20pt,inner sep=0pt]
\begin{document}
\begin{tikzpicture}[scale=1,transform shape,very thick,
  level/.style={sibling distance=60mm/#1}]
\node[vertex] {$8$}
  child { % left of 8
    node[vertex] {$3$}
      child { % left of 3
        node[vertex] {$-3$}
          child { node[vertex] {$-4$} }
          child { node[vertex] {$2$}
            child[missing] {}
            child { node[vertex] {$2$} }
          }
      }
      child { % right of 3
        node[vertex] {$6$}
          child { node[vertex] {$5$} }
          child { node[vertex] {$7$} }
      }
  }
  child { % right of 8
    node[vertex] {$17$}
      child { % left of 17
        node[vertex] {$9$}
          child[missing] {}
          child { node[vertex] {$11$} }
      }
      child { % right of 17
        node[vertex] {$19$}
          child { node[vertex] {$17$}
            child[missing] {}
            child { node[vertex] {$17$} }
          }
          child { node[vertex] {$20$} }
      }
  };
\end{tikzpicture}
\end{document}
{{< /tikztwo >}}
#+HTML:   </div>
#+HTML:   </div>
#+END_CENTER

the critical distinguishing property that makes a binary tree a *binary search tree* is:
- the left child of each node must be less than the node, and;
- the right child of this node must be larger than the node.

{{< tikzalg width="60%">}}
      \begin{algorithm}[H]
\SetAlgoLined
\KwData{BST root pointer $T$, key $k$}
\KwResult{Pointer to node with key $k$ if present, else \texttt{NIL}}
$cur \leftarrow T$\;
\While{$cur \neq \texttt{NIL}$}{
    \uIf{$k = cur.key$}{\Return $cur$}
    \uElseIf{$k < cur.key$}{$cur \leftarrow cur.left$}
    \Else{$cur \leftarrow cur.right$}
}
\Return \texttt{NIL}\;
\caption{BST-Search$(T,k)$}
      \end{algorithm}
{{< /tikzalg >}}

**** time complexity

note that the following time complexities are for a *binary search tree*, because there is really no benefit to performing these operations on a regular /binary tree/. the time complexities are all $\mathcal{O}(n)$ for the unsorted tree.

|         | Access                 | Search                 | Insertion              | Deletion               |
|---------+------------------------+------------------------+------------------------+------------------------|
| Average | $\mathcal{O}(\log(n))$ | $\mathcal{O}(\log(n))$ | $\mathcal{O}(\log(n))$ | $\mathcal{O}(\log(n))$ |
| Worst   | $\mathcal{O}(n)$       | $\mathcal{O}(n)$       | $\mathcal{O}(n)$       | $\mathcal{O}(n)$       |
|---------+------------------------+------------------------+------------------------+------------------------|

naturally, this table warrants explanation. though currently I have none.

I can reconcile average complexity of search to take log n steps, but I wonder why worst case is not the same.

I wonder if insertion causes a total rebalancing to occur. is a Binary Search Tree even balanced?

***** full vs. complete vs. balanced vs. perfect

#+BEGIN_CENTER
#+HTML: <div style="display:flex; align-items:flex-start; justify-content:center; gap:20px; flex-wrap:wrap;">

#+HTML:   <div style="text-align:center; display:flex; flex-direction:column; align-items:center;">
#+CAPTION: 1. complete binary tree (not full)
#+ATTR_HTML: :width 300px :class lateximage
{{< tikztwo >}}
\usetikzlibrary{arrows,positioning, calc}
\tikzstyle{vertex}=[draw,fill=black!15,circle,minimum size=20pt,inner sep=0pt]
\begin{document}
\begin{tikzpicture}[scale=2,transform shape,very thick,
  level/.style={sibling distance=30mm/#1}]
\node[vertex] {$1$}
  child {
    node[vertex] {$2$}
      child { node[vertex] {$4$} }
      child { node[vertex] {$5$} }
  }
  child {
    node[vertex] {$3$}
      child { node[vertex] {$6$} }
      child[missing] {}
  };
\end{tikzpicture}
\end{document}
{{< /tikztwo >}}
#+HTML:   </div>

#+HTML:   <div style="text-align:center; display:flex; flex-direction:column; align-items:center;">
#+CAPTION: 2. full binary tree (not complete)
#+ATTR_HTML: :width 300px :class lateximage
{{< tikztwo >}}
\usetikzlibrary{arrows,positioning, calc}
\tikzstyle{vertex}=[draw,fill=black!15,circle,minimum size=20pt,inner sep=0pt]
\begin{document}
\begin{tikzpicture}[scale=2,transform shape,very thick,
  level/.style={sibling distance=30mm/#1}]
\node[vertex] {$1$}
  child { node[vertex] {$2$} } % leaf: 0 children
  child {
    node[vertex] {$3$}
      child { node[vertex] {$6$} } % two children → "full"
      child { node[vertex] {$7$} }
  };
\end{tikzpicture}
\end{document}
{{< /tikztwo >}}
#+HTML:   </div>

#+HTML:   <div style="text-align:center; display:flex; flex-direction:column; align-items:center;">
#+CAPTION: 3. perfect binary tree (full + complete)
#+ATTR_HTML: :width 300px :class lateximage
{{< tikztwo >}}
\usetikzlibrary{arrows,positioning, calc}
\tikzstyle{vertex}=[draw,fill=black!15,circle,minimum size=20pt,inner sep=0pt]
\begin{document}
\begin{tikzpicture}[scale=2,transform shape,very thick,
  level/.style={sibling distance=30mm/#1}]
\node[vertex] {$1$}
  child {
    node[vertex] {$2$}
      child { node[vertex] {$4$} }
      child { node[vertex] {$5$} }
  }
  child {
    node[vertex] {$3$}
      child { node[vertex] {$6$} }
      child { node[vertex] {$7$} }
  };
\end{tikzpicture}
\end{document}
{{< /tikztwo >}}
#+HTML:   </div>

#+HTML:   <div style="text-align:center; display:flex; flex-direction:column; align-items:center;">
#+CAPTION: 4. balanced binary tree
#+ATTR_HTML: :width 300px :class lateximage
{{< tikztwo >}}
\usetikzlibrary{arrows,positioning, calc}
\tikzstyle{vertex}=[draw,fill=black!15,circle,minimum size=20pt,inner sep=0pt]
\begin{document}
\begin{tikzpicture}[scale=2,transform shape,very thick,
  level/.style={sibling distance=30mm/#1}]
\node[vertex] {$1$}
  child {
    node[vertex] {$2$}
      child[missing] {}
      child { node[vertex] {$5$} }
  }
  child { node[vertex] {$3$} };
\end{tikzpicture}
\end{document}
{{< /tikztwo >}}
#+HTML:   </div>

#+HTML: </div>
#+END_CENTER


1. *Complete binary tree*
   - every level is completely filled except possibly the last, and all nodes on the last level appear as far left as possible.
   - use-cases: binary-heap, array representations
2. *Full binary tree*
   - every /node/ has either \(0\) or \(2\) children (no node has exactly one child).
   - use-cases: huffman-encoding
3. *Perfect binary tree*
   - both full *and* complete; equivalently, all internal nodes have \(2\) children and all leaves lie at the same depth.
4. *Balanced binary tree*
   - take every node and find the height of its left-subtree and right-subtree. if the difference in heights exceed $k=1$, where $k$ can be any number criterion we choose, then the tree is unbalanced.



*** Red Black Trees

**** schematic

{{< tikztwo >}}
\usetikzlibrary{arrows}
\tikzset{
  treenode/.style = {align=center, inner sep=0pt, text centered,
    font=\sffamily},
  arn_n/.style = {treenode, circle, white, font=\sffamily\bfseries, draw=black,
    fill=black, text width=1.5em},% arbre rouge noir, noeud noir
  arn_r/.style = {treenode, circle, red, draw=red, 
    text width=1.5em, very thick},% arbre rouge noir, noeud rouge
  arn_x/.style = {treenode, rectangle, draw=black,
    minimum width=0.5em, minimum height=0.5em}% arbre rouge noir, nil
}

\begin{document}
\begin{tikzpicture}[scale=2,transform shape,->,>=stealth',level/.style={sibling distance = 5cm/#1,
  level distance = 1.5cm}] 
\node [arn_n] {33}
    child{ node [arn_r] {15} 
            child{ node [arn_n] {10} 
            	child{ node [arn_r] {5} edge from parent node[above left]
                         {$x$}} %for a named pointer
							child{ node [arn_x] {}}
            }
            child{ node [arn_n] {20}
							child{ node [arn_r] {18}}
							child{ node [arn_x] {}}
            }                            
    }
    child{ node [arn_r] {47}
            child{ node [arn_n] {38} 
							child{ node [arn_r] {36}}
							child{ node [arn_r] {39}}
            }
            child{ node [arn_n] {51}
							child{ node [arn_r] {49}}
							child{ node [arn_x] {}}
            }
		}
; 
\end{tikzpicture}
\end{document}
{{< /tikztwo >}}

#+CAPTION: another red black tree
{{< tikztwo >}}
\usetikzlibrary{trees,arrows,positioning, calc}
\tikzstyle{redVertex}  =[draw,fill=red,     circle,minimum size=18pt,inner sep=0pt, text=white]
\tikzstyle{blackVertex}=[draw,fill=black,   circle,minimum size=18pt,inner sep=0pt, text=white]
\tikzstyle{nil}        =[draw,fill=black,rectangle,minimum size=18pt,inner sep=0pt, text=white]

\begin{document}
\begin{tikzpicture}[scale=1.5,transform shape,font=\sffamily,very thick,level/.style={sibling distance=80mm/#1}]
\node [blackVertex] (r){8}
  child {
    node [blackVertex] {3}
    child {
      node [redVertex] {2}
      child {
        node [blackVertex] {-3}
        child {
            node [redVertex] {-4}
            child {node [nil] {NIL}}
            child {node [nil] {NIL}}
        }
      }
      child {
        node [blackVertex] {2}
        child {node [nil] {NIL}}
        child {node [nil] {NIL}}
      }
    }
    child {
      node [blackVertex] {6}
      child {
        node [redVertex] {5}
        child {node [nil] {NIL}}
        child {node [nil] {NIL}}
      }
      child {
        node [redVertex] {7}
        child {node [nil] {NIL}}
        child {node [nil] {NIL}}
      }
    }
  }
  child {
    node [blackVertex] {17}
    child {
      node [blackVertex] {9}
      child {
        node [redVertex] {11}
        child {node [nil] {NIL}}
        child {node [nil] {NIL}}
      }
    }
    child {
      node [redVertex] {19}
      child {
        node [blackVertex] {17}
        child {
          node [redVertex] {17}
          child {node [nil] {NIL}}
          child {node [nil] {NIL}}
        }
      }
      child {
        node [blackVertex] {20}
        child {node [nil] {NIL}}
        child {node [nil] {NIL}}
      }
    }
  };
\end{tikzpicture}
\end{document}
{{< /tikztwo >}}



#+CAPTION: small rb tree
{{< tikztwo >}}
\usetikzlibrary{trees,arrows,positioning, calc}
\tikzstyle{redVertex}  =[draw,fill=red,     circle,minimum size=18pt,inner sep=0pt, text=white]
\tikzstyle{blackVertex}=[draw,fill=black,   circle,minimum size=18pt,inner sep=0pt, text=white]
\tikzstyle{nil}        =[draw,fill=black,rectangle,minimum size=18pt,inner sep=0pt, text=white]

\begin{document}
\begin{tikzpicture}[scale=2,transform shape,font=\sffamily,very thick,level/.style={sibling distance=80mm/#1}]
\node [blackVertex] (r){2}
      child {
        node [blackVertex] {1}
        child {node [nil] {NIL}}
        child {node [nil] {NIL}}
      }
      child {
        node [blackVertex] {3}
        child {node [nil] {NIL}}
        child {node [nil] {NIL}}
      };
\end{tikzpicture}
\end{document}
{{< /tikztwo >}}



**** time complexity


|         | Access                 | Search                 | Insertion              | Deletion               |
|---------+------------------------+------------------------+------------------------+------------------------|
| Average | $\mathcal{O}(\log(n))$ | $\mathcal{O}(\log(n))$ | $\mathcal{O}(\log(n))$ | $\mathcal{O}(\log(n))$ |
| Worst   | $\mathcal{O}(\log(n))$ | $\mathcal{O}(\log(n))$ | $\mathcal{O}(\log(n))$ | $\mathcal{O}(\log(n))$ |
|---------+------------------------+------------------------+------------------------+------------------------|

I've just copied these down from [[bigocheatsheet.com]] blindly to close that tab and be done with it for now.

*** AVL Trees

Is a binary search tree that is /height balanced/; for each node $x$, the heights of the lef and right subtrees of $x$ differ by at most 1.

To implement such a tree, maintain an extra attribute $h$ in each node such that $x.h$ is the height of node $x$.

|---------+------------------------+------------------------+------------------------+------------------------|
|         | Access                 | Search                 | Insertion              | Deletion               |
|---------+------------------------+------------------------+------------------------+------------------------|
| Average | $\mathcal{O}(\log(n))$ | $\mathcal{O}(\log(n))$ | $\mathcal{O}(\log(n))$ | $\mathcal{O}(\log(n))$ |
| Worst   | $\mathcal{O}(\log(n))$ | $\mathcal{O}(\log(n))$ | $\mathcal{O}(\log(n))$ | $\mathcal{O}(\log(n))$ |
|---------+------------------------+------------------------+------------------------+------------------------|

same thing as above, here. I've just copied the time-complexities down without understanding them.

I also worry about the additional 5 'data-structures':
1. skip lists
2. cartesian tree
3. b-tree (this one makes sense)
4. splay tree
5. kd tree

and then the short few that I have found of my own accord:
1. tries
2. heaps
3. priority queue (of which heap seems to be a form of)




** heaps
:PROPERTIES:
:CUSTOM_ID: heaps
:END:


*** schematic

{{< tikztwo >}}
\usetikzlibrary{arrows,positioning, calc}
\tikzstyle{vertex}=[draw,fill=black!15,circle,minimum size=18pt,inner sep=0pt]


\begin{document}
\begin{tikzpicture}[scale=2,transform shape,very thick,level/.style={sibling distance=70mm/#1}]
\node [vertex] (r){$-4$}
  child {
    node [vertex] (a) {$2$}
    child {
      node [vertex] {$5$}
      child {
        node [vertex] {$6$}
        child {node [vertex] {$20$}}
      }
      child {
        node [vertex] {$9$}
      }
    }
    child {
      node [vertex] {$3$}
      child {node [vertex] {$19$}}
      child {node [vertex] {$7$}}
    }
  }
  child {
    node [vertex] {$-3$}
    child {
      node [vertex] {$8$}
      child {node [vertex] {$17$}}
      child {node [vertex] {$17$}}
    }
    child {
      node [vertex] {$2$}
      child {node [vertex] {$11$}}
      child {node [vertex] {$17$}}
    }
  };
\end{tikzpicture}
\end{document}
{{< /tikztwo >}}



** graphs
:PROPERTIES:
:CUSTOM_ID: graphs
:END:


*** schematic

{{< tikztwo >}}
\begin{document}
\begin{tikzpicture}[scale=2,transform shape]
     \tikzstyle{node_style} = [circle,draw=black]
     \tikzstyle{edge_style} = [draw=black]
     \node[node_style] (v1) at (-2,2) {2};
     \node[node_style] (v2) at (2,2) {3};
     \node[node_style] (v3) at (4,0) {6};
     \node[node_style] (v4) at (2,-2) {4};
     \node[node_style] (v5) at (-2,-2) {5};
     \node[node_style] (v6) at (-4,0) {1};
     \draw[edge_style]  (v1) edge (v2);
     \draw[edge_style]  (v2) edge (v3);
     \draw[edge_style]  (v3) edge (v4);
     \draw[edge_style]  (v4) edge (v5);
     \draw[edge_style]  (v5) edge (v6);
     \draw[edge_style]  (v6) edge (v1);
     \draw[edge_style]  (v5) edge (v1);
     \draw[edge_style]  (v5) edge (v2);
     \draw[edge_style]  (v4) edge (v2);
\end{tikzpicture}
\end{document}
{{< /tikztwo >}}


{{< tikztwo >}}
\usetikzlibrary{arrows,positioning, calc}
\tikzstyle{vertex}=[draw,fill=black!15,circle,minimum size=20pt,inner sep=0pt]
\tikzstyle{selected edge} = [draw,line width=5pt,-,red!50]

\begin{document}
\pgfdeclarelayer{background}
\pgfsetlayers{background,main}

\begin{tikzpicture}  [scale=2,transform shape]
  \node (a)[vertex] at (0,2) {a};
  \node (b)[vertex] at (1,1) {b};
  \node (c)[vertex] at (3,2) {c};
  \node (d)[vertex] at (4,1) {d};
  \node (e)[vertex] at (2,0) {e};
  \node (f)[vertex] at (1,3) {f};
  \node (g)[vertex] at (5,3) {g};
  \node (h)[vertex] at (0,1) {h};

  \foreach \from/\to in {a/f,f/g,h/b,b/c,c/d,d/e,e/b,f/c}
    \draw (\from) -- (\to);

  \begin{pgfonlayer}{background}
    \draw (b.center) edge[selected edge] (c.center);
    \draw (c.center) edge[selected edge] (d.center);
    \draw (d.center) edge[selected edge] (e.center);
    \draw (e.center) edge[selected edge] (b.center);
  \end{pgfonlayer}
\end{tikzpicture}
\end{document}
{{< /tikztwo >}}

*** representations

adjacency matrix, linked lists
